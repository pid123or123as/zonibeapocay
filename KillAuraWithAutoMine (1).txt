local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local Enemies = Workspace:WaitForChild("Enemies")
local Spawned = Workspace:WaitForChild("Spawned")
local Network = ReplicatedStorage:WaitForChild("Network")
local ItemsFolder = Network:WaitForChild("Items")
local ToolAction = ItemsFolder:WaitForChild("ToolAction")
local MoveItem = ItemsFolder:WaitForChild("MoveItem")
local MergeItems = ItemsFolder:WaitForChild("MergeItems")
local DropItem = ItemsFolder:WaitForChild("DropItem")
local Items = ReplicatedStorage:WaitForChild("Items")
local Camera = Workspace.CurrentCamera
local Inventory = LocalPlayer:WaitForChild("Inventory")

local Config = {
    KillAura = {
        Enabled = false,
        MaxDistance = 30,
        HighlightColor = Color3.fromRGB(255, 0, 0),
        HighlightTransparency = 0.5,
        HighlightEnabled = true,
        MinusUseRate = 0.0,
        AutoRemoveHighlightDelay = 0
    },
    AutoMine = {
        Enabled = false,
        DistanceLimit = 200,
        CheckInterval = 0.5,
        HighlightEnabled = true,
        HighlightColor = Color3.fromRGB(0, 255, 0),
        HighlightTransparency = 0.5,
        MinusUseRate = 0.7,
        DefaultUseRate = 0.85,
        Mode = "All",
        PrioritizeResources = "Stones",
        ZombieAlert_Enabled = true,
        ZombieAlert_Radius = 25,
        CacheUpdateInterval = 2.0,
        GridCellSize = 150,
        PositionUpdateThreshold = 5,
        MaxCacheSize = 300
    },
    AutoLoot = {
        Enabled = false,
        MaxDistance = 100,
        CheckInterval = 0.5,
        LootCacheUpdateInterval = 2.0,
        InventoryCheckInterval = 0.2,
        GridCellSize = 200,
        HighlightEnabled = true,
        HighlightColor = Color3.fromRGB(0, 255, 255),
        HighlightTransparency = 0.5,
        Mode = "None",
        LootCrates = { "All" },
        ItemsList = {},
        ActionDelay = 0.5,
        UseFreeSlotWhileWaiting = true,
        ValidationDelay = 0.1,
        PositionUpdateThreshold = 5,
        MaxCacheSize = 150,
        CacheCleanupInterval = 10
    },
    AutoDrop = {
        Enabled = false,
        CheckInterval = 1.0,
        ItemsToDrop = {},
        OnlyAutoLoot = true,
        ExactModeSync = false
    }
}

local PRIORITY_GROUPS = {
    Trees = { Tree = true, Palm = true },
    Stones = { Stone = true, Coal = true, IronOre = true, CopperOre = true, Sandstone = true },
    Ores = { IronOre = true, CopperOre = true }
}

local VALID_RESOURCE_TYPES = {
    Tree = true,
    Palm = true,
    Stone = true,
    Coal = true,
    IronOre = true,
    CopperOre = true,
    Sandstone = true
}

local Cache = {
    CurrentTarget = nil,
    LastTargetCheck = 0,
    TargetCheckInterval = 0.1,
    CurrentResource = nil,
    LastResourceCheck = 0,
    LastCacheUpdate = 0,
    Character = nil,
    RootPart = nil,
    PlayerPosition = nil,
    LastPositionUpdate = 0,
    ResourceGrid = {},
    PendingResources = {},
    CacheValid = { Resources = false, Loot = false },
    CurrentLoot = nil,
    LastLootCheck = 0,
    LastLootCacheUpdate = 0,
    LastInventoryCheck = 0,
    LootGrid = {},
    LootCache = {},
    ItemConfigs = {},
    InventoryTimestamps = {},
    InventoryCache = {},
    LastCacheCleanup = 0,
    LootCacheSize = 0,
    ResourceCacheSize = 0,
    LastDropCheck = 0,
    LastLootedItem = nil,
    LastLootedTime = 0
}

local Highlights = {
    KillAura = {},
    AutoMine = {},
    AutoLoot = {}
}

local uiElements = {}

local notify = print

local Core = nil

-- Функция для автоматической синхронизации конфигурации
local function SynchronizeConfigValues()
    if not uiElements then return end
    
    -- Синхронизация KillAura
    if uiElements.KillAuraMaxDistance and uiElements.KillAuraMaxDistance.GetValue then
        local uiValue = uiElements.KillAuraMaxDistance:GetValue()
        if uiValue ~= Config.KillAura.MaxDistance then
            Config.KillAura.MaxDistance = uiValue
        end
    end
    
    if uiElements.KillAuraMinusUseRate and uiElements.KillAuraMinusUseRate.GetValue then
        Config.KillAura.MinusUseRate = uiElements.KillAuraMinusUseRate:GetValue()
    end
    
    -- Синхронизация AutoMine
    if uiElements.AutoMineDistanceLimit and uiElements.AutoMineDistanceLimit.GetValue then
        local uiValue = uiElements.AutoMineDistanceLimit:GetValue()
        if uiValue ~= Config.AutoMine.DistanceLimit then
            Config.AutoMine.DistanceLimit = uiValue
            Cache.CacheValid.Resources = false
        end
    end
    
    if uiElements.AutoMineCheckInterval and uiElements.AutoMineCheckInterval.GetValue then
        Config.AutoMine.CheckInterval = uiElements.AutoMineCheckInterval:GetValue()
    end
    
    if uiElements.AutoMineZombieAlertRadius and uiElements.AutoMineZombieAlertRadius.GetValue then
        Config.AutoMine.ZombieAlert_Radius = uiElements.AutoMineZombieAlertRadius:GetValue()
    end
    
    if uiElements.AutoMineGridCellSize and uiElements.AutoMineGridCellSize.GetValue then
        local uiValue = uiElements.AutoMineGridCellSize:GetValue()
        if uiValue ~= Config.AutoMine.GridCellSize then
            Config.AutoMine.GridCellSize = uiValue
            Cache.CacheValid.Resources = false
        end
    end
    
    -- Синхронизация AutoLoot
    if uiElements.AutoLootMaxDistance and uiElements.AutoLootMaxDistance.GetValue then
        local uiValue = uiElements.AutoLootMaxDistance:GetValue()
        if uiValue ~= Config.AutoLoot.MaxDistance then
            Config.AutoLoot.MaxDistance = uiValue
            Cache.CacheValid.Loot = false
        end
    end
    
    if uiElements.AutoLootCheckInterval and uiElements.AutoLootCheckInterval.GetValue then
        Config.AutoLoot.CheckInterval = uiElements.AutoLootCheckInterval:GetValue()
    end
    
    if uiElements.AutoLootValidationDelay and uiElements.AutoLootValidationDelay.GetValue then
        Config.AutoLoot.ValidationDelay = uiElements.AutoLootValidationDelay:GetValue()
    end
    
    -- Синхронизация AutoDrop
    if uiElements.AutoDropCheckInterval and uiElements.AutoDropCheckInterval.GetValue then
        Config.AutoDrop.CheckInterval = uiElements.AutoDropCheckInterval:GetValue()
    end
end

-- Функции для управления кэшем
local function cleanupOldCache()
    if not Config.AutoLoot.Enabled and not Config.AutoMine.Enabled then
        return
    end
    
    local currentTime = tick()
    
    if currentTime - Cache.LastCacheCleanup > Config.AutoLoot.CacheCleanupInterval then
        Cache.LastCacheCleanup = currentTime
        
        for key, data in pairs(Cache.InventoryCache) do
            if currentTime - (Cache.InventoryTimestamps[data.folder] or 0) > 30 then
                Cache.InventoryCache[key] = nil
            end
        end
        
        local lootToRemove = {}
        for lootModel, data in pairs(Cache.LootCache) do
            if not lootModel.Parent or not lootModel:IsA("Model") then
                table.insert(lootToRemove, lootModel)
            elseif data.lastSeen and currentTime - data.lastSeen > 120 then
                table.insert(lootToRemove, lootModel)
            end
        end
        
        for _, lootModel in ipairs(lootToRemove) do
            removeLootFromGrid(lootModel)
            removeHighlight(lootModel, "AutoLoot")
        end
        
        local resourcesRemoved = 0
        for key, cell in pairs(Cache.ResourceGrid) do
            for groupName, group in pairs(cell) do
                for i = #group, 1, -1 do
                    local resource = group[i]
                    if not resource.obj.Parent or not resource.obj:IsA("Model") then
                        table.remove(group, i)
                        Cache.ResourceCacheSize = Cache.ResourceCacheSize - 1
                        resourcesRemoved = resourcesRemoved + 1
                    elseif resource.lastSeen and currentTime - resource.lastSeen > 120 then
                        table.remove(group, i)
                        Cache.ResourceCacheSize = Cache.ResourceCacheSize - 1
                        resourcesRemoved = resourcesRemoved + 1
                    end
                end
            end
            if next(cell.Trees) == nil and next(cell.Stones) == nil and next(cell.Ores) == nil then
                Cache.ResourceGrid[key] = nil
            end
        end
        
        for mode, highlightTable in pairs(Highlights) do
            local toRemove = {}
            for target, highlight in pairs(highlightTable) do
                if not target.Parent or not target:IsA("Model") then
                    table.insert(toRemove, target)
                end
            end
            for _, target in ipairs(toRemove) do
                removeHighlight(target, mode)
            end
        end
    end
end

local function enforceCacheLimits()
    if Cache.LootCacheSize > Config.AutoLoot.MaxCacheSize then
        local toRemove = Cache.LootCacheSize - Config.AutoLoot.MaxCacheSize
        local removed = 0
        
        local oldestEntries = {}
        for lootModel, data in pairs(Cache.LootCache) do
            if lootModel ~= Cache.CurrentLoot then
                table.insert(oldestEntries, { model = lootModel, timestamp = data.lastSeen or 0 })
            end
        end
        
        if #oldestEntries > 0 then
            table.sort(oldestEntries, function(a, b)
                return a.timestamp < b.timestamp
            end)
            
            for i = 1, math.min(toRemove, #oldestEntries) do
                local entry = oldestEntries[i]
                removeLootFromGrid(entry.model)
                removeHighlight(entry.model, "AutoLoot")
                removed = removed + 1
            end
            
            Cache.LootCacheSize = Cache.LootCacheSize - removed
        end
    end
end

local function createHighlight(target, mode)
    if not target or not target.Parent then return end
    
    local highlightTable = mode == "AutoMine" and Highlights.AutoMine or mode == "AutoLoot" and Highlights.AutoLoot or Highlights.KillAura
    local config = mode == "AutoMine" and Config.AutoMine or mode == "AutoLoot" and Config.AutoLoot or Config.KillAura
    
    if config.HighlightEnabled and not highlightTable[target] then
        local highlight = Instance.new("Highlight")
        highlight.Adornee = target
        highlight.FillColor = config.HighlightColor
        highlight.FillTransparency = config.HighlightTransparency
        highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
        highlight.OutlineTransparency = 0
        highlight.Parent = target
        highlightTable[target] = highlight
    end
end

local function removeHighlight(target, mode)
    if not target then return end
    
    local highlightTable = mode == "AutoMine" and Highlights.AutoMine or mode == "AutoLoot" and Highlights.AutoLoot or Highlights.KillAura
    local highlight = highlightTable[target]
    if highlight then
        highlight:Destroy()
        highlightTable[target] = nil
    end
end

local function clearKillAuraHighlights(currentTarget)
    for target, highlight in pairs(Highlights.KillAura) do
        if target ~= currentTarget then
            removeHighlight(target, "KillAura")
        end
    end
end

local function clearAutoLootHighlights(currentLoot)
    for target, highlight in pairs(Highlights.AutoLoot) do
        if target ~= currentLoot then
            removeHighlight(target, "AutoLoot")
        end
    end
end

local function isValidWeapon()
    if not Config.KillAura.Enabled then return false end
    
    Cache.Character = Cache.Character or LocalPlayer.Character
    if not Cache.Character then return false end
    
    local item = Cache.Character:FindFirstChild("Item")
    if not item then return false end
    
    local model = item:FindFirstChildWhichIsA("Model")
    if not model then return false end
    
    local config = model:FindFirstChild("Config")
    local meleeConfig = model:FindFirstChild("MeleeConfig")
    if not config or not meleeConfig then return false end
    
    local configData = require(config)
    if configData.toolType ~= "Melee" or not configData.useRate then
        return false
    end
    
    return true, configData.useRate
end

local function findPlayerItem()
    if not Config.AutoMine.Enabled then return nil, Config.AutoMine.DefaultUseRate end
    
    Cache.Character = Cache.Character or LocalPlayer.Character
    if not Cache.Character then return nil, Config.AutoMine.DefaultUseRate end
    
    local vm = Camera:FindFirstChild("VM")
    if not vm then return nil, Config.AutoMine.DefaultUseRate end
    
    local item = vm:FindFirstChildWhichIsA("Tool")
    if not item then return nil, Config.AutoMine.DefaultUseRate end
    
    local model = item:FindFirstChildWhichIsA("Model")
    if not model then return nil, Config.AutoMine.DefaultUseRate end
    
    local configModule = model:FindFirstChild("Config")
    if not configModule or not configModule:IsA("ModuleScript") then
        return nil, Config.AutoMine.DefaultUseRate
    end
    
    local success, configTable = pcall(require, configModule)
    if not success or not configTable or configTable.class ~= "tool" then
        return nil, Config.AutoMine.DefaultUseRate
    end
    
    local meleeConfig = model:FindFirstChild("MeleeConfig")
    local gunConfig = model:FindFirstChild("GunConfig")
    if meleeConfig or gunConfig then
        return nil, Config.AutoMine.DefaultUseRate
    end
    
    local useRate = configTable.useRate or Config.AutoMine.DefaultUseRate
    return item, math.max(0.1, useRate - Config.AutoMine.MinusUseRate)
end

local function getBaseItemName(itemName)
    return itemName:match("^[^_]+") or itemName
end

local function getItemConfig(itemName)
    if Cache.ItemConfigs[itemName] then
        return Cache.ItemConfigs[itemName]
    end
    
    local itemModel = Items:FindFirstChild(itemName)
    local config = { maxStack = 1, class = nil }
    
    if itemModel then
        local configModule = itemModel:FindFirstChild("Config")
        if configModule and configModule:IsA("ModuleScript") then
            local success, configTable = pcall(require, configModule)
            if success and configTable then
                config.maxStack = configTable.maxStack or 1
                config.class = configTable.class or nil
            end
        end
    end
    
    Cache.ItemConfigs[itemName] = config
    return config
end

-- ИСПРАВЛЕННАЯ ФУНКЦИЯ: Проверка, должен ли предмет быть взят AutoLoot
local function isItemAllowed(itemName)
    local baseItemName = getBaseItemName(itemName)
    
    -- Если включен ExactModeSync и AutoLoot в режиме Exact
    if Config.AutoDrop.ExactModeSync and Config.AutoLoot.Mode == "Exact" then
        -- В этом режиме AutoLoot ДОЛЖЕН собирать ВСЕ предметы (не только из списка)
        return true
    end
    
    -- Обычная логика AutoLoot без ExactModeSync
    if Config.AutoLoot.Mode == "None" then
        return true
    elseif Config.AutoLoot.Mode == "Exact" then
        -- Берем ТОЛЬКО предметы из списка ItemsList
        local itemsList = Config.AutoLoot.ItemsList
        if type(itemsList) == "table" then
            for item, enabled in pairs(itemsList) do
                if (type(enabled) == "boolean" and enabled and baseItemName == item) or
                   (type(enabled) == "string" and baseItemName == enabled) then
                    return true
                end
            end
        end
        return false
    elseif Config.AutoLoot.Mode == "Exclude" then
        -- Берем все предметы КРОМЕ тех, что в списке ItemsList
        local itemsList = Config.AutoLoot.ItemsList
        if type(itemsList) == "table" then
            for item, enabled in pairs(itemsList) do
                if (type(enabled) == "boolean" and enabled and baseItemName == item) or
                   (type(enabled) == "string" and baseItemName == enabled) then
                    return false
                end
            end
        end
        return true
    end
    return true
end

local function findFreeSlot(inventory, maxSlots)
    for slot = 1, maxSlots do
        local slotTaken = false
        for _, itemFolder in ipairs(inventory:GetChildren()) do
            local indexValue = itemFolder:FindFirstChild("Index")
            if indexValue and indexValue.Value == slot then
                slotTaken = true
                break
            end
        end
        if not slotTaken then
            return slot
        end
    end
    return nil
end

local function findExistingItemFolder(inventory, itemName, lootItem)
    local currentTime = tick()
    if currentTime - Cache.LastInventoryCheck < Config.AutoLoot.InventoryCheckInterval then
        local cachedResult = Cache.InventoryCache[itemName]
        if cachedResult and cachedResult.folder.Parent then
            return cachedResult.folder, cachedResult.slot
        end
    end
    
    local baseItemName = getBaseItemName(itemName)
    local itemConfig = getItemConfig(baseItemName)
    local maxStack = itemConfig.maxStack
    
    if maxStack <= 1 then
        return nil, nil
    end
    
    for _, itemFolder in ipairs(inventory:GetChildren()) do
        if getBaseItemName(itemFolder.Name) == baseItemName then
            local countValue = itemFolder:FindFirstChild("Count")
            local indexValue = itemFolder:FindFirstChild("Index")
            if countValue and indexValue and itemFolder ~= lootItem then
                if countValue.Value < maxStack then
                    local timestamp = Cache.InventoryTimestamps[itemFolder] or 0
                    if currentTime - timestamp >= Config.AutoLoot.ValidationDelay then
                        Cache.InventoryCache[itemName] = { folder = itemFolder, slot = indexValue.Value }
                        Cache.InventoryTimestamps[itemFolder] = currentTime
                        Cache.LastInventoryCheck = currentTime
                        return itemFolder, indexValue.Value
                    end
                end
            end
        end
    end
    Cache.InventoryCache[itemName] = nil
    Cache.LastInventoryCheck = currentTime
    return nil, nil
end

local function getGridKey(pos, cellSize)
    local x = math.floor(pos.X / cellSize)
    local y = math.floor(pos.Y / cellSize)
    local z = math.floor(pos.Z / cellSize)
    return x .. "," .. y .. "," .. z
end

local function addLootToGrid(lootModel, pos, items)
    if not lootModel:IsA("Model") or not lootModel.Parent or not lootModel.PrimaryPart then return end
    
    local currentTime = tick()
    local key = getGridKey(pos, Config.AutoLoot.GridCellSize)
    
    if not Cache.LootGrid[key] then
        Cache.LootGrid[key] = {}
    end
    
    if not Cache.LootGrid[key][lootModel] then
        Cache.LootGrid[key][lootModel] = { 
            items = items, 
            position = pos,
            lastSeen = currentTime
        }
        Cache.LootCache[lootModel] = Cache.LootGrid[key][lootModel]
        Cache.LootCacheSize = Cache.LootCacheSize + 1
    else
        Cache.LootGrid[key][lootModel].lastSeen = currentTime
        Cache.LootGrid[key][lootModel].items = items
        Cache.LootCache[lootModel].lastSeen = currentTime
        Cache.LootCache[lootModel].items = items
    end
end

local function removeLootFromGrid(lootModel)
    local removed = false
    for key, cell in pairs(Cache.LootGrid) do
        if cell[lootModel] then
            cell[lootModel] = nil
            removed = true
            if next(cell) == nil then
                Cache.LootGrid[key] = nil
            end
        end
    end
    if Cache.LootCache[lootModel] then
        Cache.LootCache[lootModel] = nil
        if removed then
            Cache.LootCacheSize = math.max(0, Cache.LootCacheSize - 1)
        end
    end
end

local function parseLootCratesSelection(selection)
    if type(selection) == "table" then
        local result = {}
        
        for key, value in pairs(selection) do
            if type(value) == "boolean" and value == true then
                if key == "All" or key == "CommonLoot" or key == "RareLoot" or key == "UncommonLoot" then
                    table.insert(result, key)
                elseif key == "Common" then
                    table.insert(result, "CommonLoot")
                elseif key == "Rare" then
                    table.insert(result, "RareLoot")
                elseif key == "Uncommon" then
                    table.insert(result, "UncommonLoot")
                end
            end
        end
        
        if #result == 0 then
            for _, value in ipairs(selection) do
                if type(value) == "string" then
                    if value == "All" or value == "CommonLoot" or value == "RareLoot" or value == "UncommonLoot" then
                        table.insert(result, value)
                    elseif value == "Common" then
                        table.insert(result, "CommonLoot")
                    elseif value == "Rare" then
                        table.insert(result, "RareLoot")
                    elseif value == "Uncommon" then
                        table.insert(result, "UncommonLoot")
                    end
                end
            end
        end
        
        if #result == 0 then
            return { "All" }
        end
        
        return result
    elseif type(selection) == "string" then
        if selection == "Common" then return { "CommonLoot" }
        elseif selection == "Rare" then return { "RareLoot" }
        elseif selection == "Uncommon" then return { "UncommonLoot" }
        else return { selection }
        end
    else
        return { "All" }
    end
end

local function getLootTypes()
    local lootCrates = parseLootCratesSelection(Config.AutoLoot.LootCrates)
    
    local lootTypes = {}
    
    for _, crate in ipairs(lootCrates) do
        if crate == "All" then
            lootTypes["CommonLoot"] = true
            lootTypes["RareLoot"] = true
            lootTypes["UncommonLoot"] = true
            break
        else
            lootTypes[crate] = true
        end
    end
    
    return lootTypes
end

local function initializeLootCache()
    if not Config.AutoLoot.Enabled then return end
    
    Cache.LootGrid = {}
    Cache.LootCache = {}
    Cache.LootCacheSize = 0
    
    local lootTypes = getLootTypes()
    
    for _, lootModel in ipairs(Spawned:GetChildren()) do
        if lootModel:IsA("Model") and lootModel.Parent and lootModel.PrimaryPart then
            if lootTypes[lootModel.Name] then
                local inventoryFolder = lootModel:FindFirstChild("Inventory")
                if inventoryFolder then
                    local items = {}
                    for _, itemFolder in ipairs(inventoryFolder:GetChildren()) do
                        if isItemAllowed(itemFolder.Name) then
                            table.insert(items, itemFolder)
                        end
                    end
                    if #items > 0 then
                        addLootToGrid(lootModel, lootModel.PrimaryPart.Position, items)
                        if Config.AutoLoot.HighlightEnabled then
                            createHighlight(lootModel, "AutoLoot")
                        end
                    end
                end
            end
        end
    end
    
    Cache.CacheValid.Loot = true
    Cache.LastLootCacheUpdate = tick()
    
    enforceCacheLimits()
end

local function findNearestLoot()
    if not Config.AutoLoot.Enabled then
        if Cache.CurrentLoot then
            removeHighlight(Cache.CurrentLoot, "AutoLoot")
            Cache.CurrentLoot = nil
        end
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.AutoLootItemName = nil
        end
        return nil, nil, nil
    end
    
    Cache.Character = Cache.Character or LocalPlayer.Character
    if not Cache.Character then
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.AutoLootItemName = nil
        end
        return nil, nil, nil
    end
    
    Cache.RootPart = Cache.RootPart or Cache.Character:FindFirstChild("HumanoidRootPart")
    if not Cache.RootPart then
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.AutoLootItemName = nil
        end
        return nil, nil, nil
    end
    
    local currentTime = tick()
    local playerPos = Cache.RootPart.Position
    
    if Cache.PlayerPosition and (currentTime - Cache.LastPositionUpdate < Config.AutoLoot.CheckInterval) then
        local dx = playerPos.X - Cache.PlayerPosition.X
        local dy = playerPos.Y - Cache.PlayerPosition.Y
        local dz = playerPos.Z - Cache.PlayerPosition.Z
        if dx * dx + dy * dy + dz * dz < Config.AutoLoot.PositionUpdateThreshold ^ 2 then
            playerPos = Cache.PlayerPosition
        else
            Cache.PlayerPosition = playerPos
            Cache.LastPositionUpdate = currentTime
        end
    else
        Cache.PlayerPosition = playerPos
        Cache.LastPositionUpdate = currentTime
    end
    
    if currentTime - Cache.LastLootCacheUpdate > Config.AutoLoot.LootCacheUpdateInterval or not Cache.CacheValid.Loot then
        initializeLootCache()
    end
    
    local nearestLoot, nearestItem, nearestModel, minDistanceSqr = nil, nil, nil, math.huge
    local maxDistanceSqr = Config.AutoLoot.MaxDistance ^ 2
    local cellSize = Config.AutoLoot.GridCellSize
    local gridRadius = math.ceil(Config.AutoLoot.MaxDistance / cellSize) + 1
    local playerX, playerY, playerZ = math.floor(playerPos.X / cellSize), math.floor(playerPos.Y / cellSize), math.floor(playerPos.Z / cellSize)
    
    for x = playerX - gridRadius, playerX + gridRadius do
        for y = playerY - gridRadius, playerY + gridRadius do
            for z = playerZ - gridRadius, playerZ + gridRadius do
                local key = x .. "," .. y .. "," .. z
                local cell = Cache.LootGrid[key]
                if cell then
                    for lootModel, data in pairs(cell) do
                        if lootModel.Parent and lootModel.PrimaryPart then
                            data.lastSeen = currentTime
                            Cache.LootCache[lootModel].lastSeen = currentTime
                            
                            local dx = playerPos.X - data.position.X
                            local dy = playerPos.Y - data.position.Y
                            local dz = playerPos.Z - data.position.Z
                            local distSqr = dx * dx + dy * dy + dz * dz
                            
                            if distSqr <= maxDistanceSqr and distSqr < minDistanceSqr then
                                for _, itemFolder in ipairs(data.items) do
                                    if itemFolder.Parent and itemFolder.Parent.Parent == lootModel then
                                        nearestLoot = itemFolder
                                        nearestItem = itemFolder.Name
                                        nearestModel = lootModel
                                        minDistanceSqr = distSqr
                                        break
                                    end
                                end
                            end
                        else
                            removeLootFromGrid(lootModel)
                            removeHighlight(lootModel, "AutoLoot")
                        end
                    end
                end
            end
        end
    end
    
    if nearestLoot then
        if Cache.CurrentLoot and Cache.CurrentLoot ~= nearestModel then
            removeHighlight(Cache.CurrentLoot, "AutoLoot")
        end
        Cache.CurrentLoot = nearestModel
        if Config.AutoLoot.HighlightEnabled then
            createHighlight(nearestModel, "AutoLoot")
        end
    elseif Cache.CurrentLoot then
        removeHighlight(Cache.CurrentLoot, "AutoLoot")
        Cache.CurrentLoot = nil
    end
    
    if Core and Core.TheApocalypse then
        Core.TheApocalypse.AutoLootItemName = nearestItem
    end
    
    return nearestLoot, nearestItem, nearestModel
end

local function getValidResourceTypes()
    if Config.AutoMine.Mode == "All" then
        return VALID_RESOURCE_TYPES
    else
        return { [Config.AutoMine.Mode] = true }
    end
end

local function addResourceToGrid(obj, pos)
    if not obj:IsA("Model") or not obj.Parent or not obj.PrimaryPart then return end
    local config = obj:FindFirstChild("Configuration")
    local health = config and config:GetAttribute("Health") or 0
    if health <= 0 then return end
    
    local validTypes = getValidResourceTypes()
    for resourceType in pairs(validTypes) do
        if string.find(obj.Name, resourceType) then
            local resourceData = { obj = obj, position = pos, health = health, lastSeen = tick() }
            local key = getGridKey(pos, Config.AutoMine.GridCellSize)
            Cache.ResourceGrid[key] = Cache.ResourceGrid[key] or { Trees = {}, Stones = {}, Ores = {} }
            if PRIORITY_GROUPS.Trees[resourceType] then
                table.insert(Cache.ResourceGrid[key].Trees, resourceData)
            end
            if PRIORITY_GROUPS.Stones[resourceType] then
                table.insert(Cache.ResourceGrid[key].Stones, resourceData)
            end
            if PRIORITY_GROUPS.Ores[resourceType] then
                table.insert(Cache.ResourceGrid[key].Ores, resourceData)
            end
            Cache.ResourceCacheSize = Cache.ResourceCacheSize + 1
            break
        end
    end
end

local function removeResourceFromGrid(obj)
    for key, gridCell in pairs(Cache.ResourceGrid) do
        for _, group in pairs({"Trees", "Stones", "Ores"}) do
            for i = #gridCell[group], 1, -1 do
                if gridCell[group][i].obj == obj then
                    table.remove(gridCell[group], i)
                    Cache.ResourceCacheSize = math.max(0, Cache.ResourceCacheSize - 1)
                end
            end
        end
    end
end

local function initializeResourceCache()
    if not Config.AutoMine.Enabled then return end
    
    Cache.ResourceGrid = {}
    Cache.PendingResources = {}
    Cache.ResourceCacheSize = 0
    local validTypes = getValidResourceTypes()
    for _, obj in ipairs(Spawned:GetChildren()) do
        if obj:IsA("Model") and obj.Parent and obj.PrimaryPart then
            for resourceType in pairs(validTypes) do
                if string.find(obj.Name, resourceType) then
                    addResourceToGrid(obj, obj.PrimaryPart.Position)
                    break
                end
            end
        end
    end
    Cache.CacheValid.Resources = true
end

local function processPendingResources()
    if not Config.AutoMine.Enabled then return end
    
    local currentTime = tick()
    if currentTime - Cache.LastCacheUpdate < Config.AutoMine.CacheUpdateInterval then
        return
    end
    Cache.LastCacheUpdate = currentTime
    
    for i = #Cache.PendingResources, 1, -1 do
        local obj = Cache.PendingResources[i]
        if obj.Parent and obj.PrimaryPart then
            addResourceToGrid(obj, obj.PrimaryPart.Position)
            table.remove(Cache.PendingResources, i)
        else
            table.remove(Cache.PendingResources, i)
        end
    end
end

local function checkZombieAlert()
    if not Config.AutoMine.Enabled or not Config.AutoMine.ZombieAlert_Enabled then
        return false
    end
    
    Cache.RootPart = Cache.RootPart or (Cache.Character and Cache.Character:FindFirstChild("HumanoidRootPart"))
    if not Cache.RootPart then return false end
    Cache.PlayerPosition = Cache.PlayerPosition or Cache.RootPart.Position
    
    local radiusSqr = Config.AutoMine.ZombieAlert_Radius ^ 2
    local enemies = Enemies:GetChildren()
    
    for _, enemy in ipairs(enemies) do
        local humanoid = enemy:FindFirstChildOfClass("Humanoid")
        local root = enemy:FindFirstChild("HumanoidRootPart")
        if humanoid and root and humanoid.Health > 0 then
            local dx = Cache.PlayerPosition.X - root.Position.X
            local dy = Cache.PlayerPosition.Y - root.Position.Y
            local dz = Cache.PlayerPosition.Z - root.Position.Z
            if dx * dx + dy * dy + dz * dz <= radiusSqr then
                return true
            end
        end
    end
    return false
end

local function findNearestResource()
    if not Config.AutoMine.Enabled then
        if Cache.CurrentResource then
            removeHighlight(Cache.CurrentResource.obj, "AutoMine")
            Cache.CurrentResource = nil
        end
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.AutoMineOreName = nil
            Core.TheApocalypse.AutoMineHealthOre = nil
        end
        return nil
    end
    
    Cache.Character = Cache.Character or LocalPlayer.Character
    if not Cache.Character then
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.AutoMineOreName = nil
            Core.TheApocalypse.AutoMineHealthOre = nil
        end
        return nil
    end
    
    Cache.RootPart = Cache.RootPart or Cache.Character:FindFirstChild("HumanoidRootPart")
    if not Cache.RootPart then
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.AutoMineOreName = nil
            Core.TheApocalypse.AutoMineHealthOre = nil
        end
        return nil
    end
    
    local currentTime = tick()
    local playerPos = Cache.RootPart.Position
    if Cache.PlayerPosition and (currentTime - Cache.LastPositionUpdate < Config.AutoMine.CheckInterval) then
        local dx = playerPos.X - Cache.PlayerPosition.X
        local dy = playerPos.Y - Cache.PlayerPosition.Y
        local dz = playerPos.Z - Cache.PlayerPosition.Z
        if dx * dx + dy * dy + dz * dz < Config.AutoMine.PositionUpdateThreshold ^ 2 then
            playerPos = Cache.PlayerPosition
        else
            Cache.PlayerPosition = playerPos
            Cache.LastPositionUpdate = currentTime
        end
    else
        Cache.PlayerPosition = playerPos
        Cache.LastPositionUpdate = currentTime
    end
    
    if Cache.CurrentResource then
        local obj = Cache.CurrentResource.obj
        if obj and obj.Parent and obj.PrimaryPart then
            local config = obj:FindFirstChild("Configuration")
            local health = config and config:GetAttribute("Health") or 0
            if health > 0 then
                local dx = playerPos.X - Cache.CurrentResource.position.X
                local dy = playerPos.Y - Cache.CurrentResource.position.Y
                local dz = playerPos.Z - Cache.CurrentResource.position.Z
                if dx * dx + dy * dy + dz * dz <= Config.AutoMine.DistanceLimit ^ 2 then
                    Cache.CurrentResource.health = health
                    Cache.CurrentResource.lastSeen = currentTime
                    if Core and Core.TheApocalypse then
                        Core.TheApocalypse.AutoMineOreName = obj.Name
                        Core.TheApocalypse.AutoMineHealthOre = health
                    end
                    return obj
                end
            else
                removeHighlight(obj, "AutoMine")
                removeResourceFromGrid(obj)
                Cache.CurrentResource = nil
                if Core and Core.TheApocalypse then
                    Core.TheApocalypse.AutoMineOreName = nil
                    Core.TheApocalypse.AutoMineHealthOre = nil
                end
            end
        else
            removeHighlight(obj, "AutoMine")
            removeResourceFromGrid(obj)
            Cache.CurrentResource = nil
            if Core and Core.TheApocalypse then
                Core.TheApocalypse.AutoMineOreName = nil
                Core.TheApocalypse.AutoMineHealthOre = nil
            end
        end
    end
    
    if not Cache.CacheValid.Resources then
        initializeResourceCache()
    end
    processPendingResources()
    
    local distanceLimitSqr = Config.AutoMine.DistanceLimit ^ 2
    
    local function findClosestInGroup(group, gridCells)
        local closestResource, closestHealth, minDistanceSqr = nil, nil, distanceLimitSqr
        for _, key in ipairs(gridCells) do
            local cell = Cache.ResourceGrid[key]
            if cell then
                for _, resource in ipairs(cell[group]) do
                    if resource and resource.obj.Parent and resource.obj.PrimaryPart then
                        local config = resource.obj:FindFirstChild("Configuration")
                        local health = config and config:GetAttribute("Health") or 0
                        if health > 0 then
                            local dx = playerPos.X - resource.position.X
                            local dy = playerPos.Y - resource.position.Y
                            local dz = playerPos.Z - resource.position.Z
                            local distSqr = dx * dx + dy * dy + dz * dz
                            if distSqr <= minDistanceSqr then
                                closestResource = resource.obj
                                closestHealth = health
                                resource.health = health
                                resource.lastSeen = currentTime
                                minDistanceSqr = distSqr
                            end
                        end
                    end
                end
            end
        end
        return closestResource, closestHealth, minDistanceSqr
    end
    
    local cellSize = Config.AutoMine.GridCellSize
    local gridRadius = math.ceil(Config.AutoMine.DistanceLimit / cellSize) + 1
    local playerX, playerY, playerZ = math.floor(playerPos.X / cellSize), math.floor(playerPos.Y / cellSize), math.floor(playerPos.Z / cellSize)
    local gridCells = {}
    for x = playerX - gridRadius, playerX + gridRadius do
        for y = playerY - gridRadius, playerY + gridRadius do
            for z = playerZ - gridRadius, playerZ + gridRadius do
                table.insert(gridCells, x .. "," .. y .. "," .. z)
            end
        end
    end
    
    local closestResource, closestHealth, closestDistanceSqr = nil, nil, math.huge
    local priorityGroup = Config.AutoMine.PrioritizeResources
    if priorityGroup ~= "None" then
        closestResource, closestHealth, closestDistanceSqr = findClosestInGroup(priorityGroup, gridCells)
        if closestResource then
            Cache.CurrentResource = { 
                obj = closestResource, 
                position = closestResource.PrimaryPart.Position, 
                health = closestHealth,
                lastSeen = currentTime
            }
            Cache.LastResourceCheck = currentTime
            if Core and Core.TheApocalypse then
                Core.TheApocalypse.AutoMineOreName = closestResource.Name
                Core.TheApocalypse.AutoMineHealthOre = closestHealth
            end
            return closestResource
        end
        for _, group in ipairs({ "Trees", "Stones", "Ores" }) do
            if group ~= priorityGroup then
                local groupResource, groupHealth, groupDistanceSqr = findClosestInGroup(group, gridCells)
                if groupResource and groupDistanceSqr < closestDistanceSqr then
                    closestResource = groupResource
                    closestHealth = groupHealth
                    closestDistanceSqr = groupDistanceSqr
                end
            end
        end
    else
        for _, group in ipairs({ "Trees", "Stones", "Ores"}) do
            local groupResource, groupHealth, groupDistanceSqr = findClosestInGroup(group, gridCells)
            if groupResource and groupDistanceSqr < closestDistanceSqr then
                closestResource = groupResource
                closestHealth = groupHealth
                closestDistanceSqr = groupDistanceSqr
            end
        end
    end
    
    Cache.CurrentResource = closestResource and { 
        obj = closestResource, 
        position = closestResource.PrimaryPart.Position, 
        health = closestHealth,
        lastSeen = currentTime
    }
    Cache.LastResourceCheck = currentTime
    if Core and Core.TheApocalypse then
        Core.TheApocalypse.AutoMineOreName = closestResource and closestResource.Name or nil
        Core.TheApocalypse.AutoMineHealthOre = closestResource and closestHealth or nil
    end
    return closestResource
end

local function getNearestTarget()
    if not Config.KillAura.Enabled then
        if Cache.CurrentTarget then
            removeHighlight(Cache.CurrentTarget, "KillAura")
            Cache.CurrentTarget = nil
        end
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.isTargetNear = false
        end
        return nil
    end
    
    Cache.Character = Cache.Character or LocalPlayer.Character
    if not Cache.Character then
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.isTargetNear = false
        end
        return nil
    end
    
    Cache.RootPart = Cache.RootPart or Cache.Character:FindFirstChild("HumanoidRootPart")
    if not Cache.RootPart then
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.isTargetNear = false
        end
        return nil
    end
    
    local currentTime = tick()
    local playerPos = Cache.RootPart.Position
    if Cache.PlayerPosition and (currentTime - Cache.LastPositionUpdate < Config.AutoMine.CheckInterval) then
        local dx = playerPos.X - Cache.PlayerPosition.X
        local dy = playerPos.Y - Cache.PlayerPosition.Y
        local dz = playerPos.Z - Cache.PlayerPosition.Z
        if dx * dx + dy * dy + dz * dz < Config.AutoMine.PositionUpdateThreshold ^ 2 then
            playerPos = Cache.PlayerPosition
        else
            Cache.PlayerPosition = playerPos
            Cache.LastPositionUpdate = currentTime
        end
    else
        Cache.PlayerPosition = playerPos
        Cache.LastPositionUpdate = currentTime
    end
    
    if Cache.CurrentTarget and currentTime - Cache.LastTargetCheck < Cache.TargetCheckInterval then
        local humanoid = Cache.CurrentTarget:FindFirstChildOfClass("Humanoid")
        local root = Cache.CurrentTarget:FindFirstChild("HumanoidRootPart")
        local serverModel = Cache.CurrentTarget:FindFirstChild("ServerModel")
        if humanoid and root and humanoid.Health > 0 and serverModel and serverModel.Value then
            local dx = playerPos.X - root.Position.X
            local dy = playerPos.Y - root.Position.Y
            local dz = playerPos.Z - root.Position.Z
            if dx * dx + dy * dy + dz * dz <= Config.KillAura.MaxDistance ^ 2 then
                if Core and Core.TheApocalypse then
                    Core.TheApocalypse.isTargetNear = true
                end
                return Cache.CurrentTarget
            else
                removeHighlight(Cache.CurrentTarget, "KillAura")
                Cache.CurrentTarget = nil
            end
        else
            removeHighlight(Cache.CurrentTarget, "KillAura")
            Cache.CurrentTarget = nil
        end
    end
    
    local nearestTarget, minDistanceSqr = nil, Config.KillAura.MaxDistance ^ 2
    for _, enemy in ipairs(Enemies:GetChildren()) do
        local humanoid = enemy:FindFirstChildOfClass("Humanoid")
        local root = enemy:FindFirstChild("HumanoidRootPart")
        local serverModel = enemy:FindFirstChild("ServerModel")
        
        if humanoid and root and humanoid.Health > 0 and serverModel and serverModel.Value then
            local dx = playerPos.X - root.Position.X
            local dy = playerPos.Y - root.Position.Y
            local dz = playerPos.Z - root.Position.Z
            local distSqr = dx * dx + dy * dy + dz * dz
            if distSqr <= minDistanceSqr then
                nearestTarget = enemy
                minDistanceSqr = distSqr
            end
        end
    end
    
    if Cache.CurrentTarget and Cache.CurrentTarget ~= nearestTarget then
        removeHighlight(Cache.CurrentTarget, "KillAura")
    end
    Cache.CurrentTarget = nearestTarget
    Cache.LastTargetCheck = currentTime
    if Core and Core.TheApocalypse then
        Core.TheApocalypse.isTargetNear = nearestTarget ~= nil
    end
    return nearestTarget
end

local function attackTarget(target, useRate)
    if not target then return end
    
    Cache.RootPart = Cache.RootPart or (Cache.Character and Cache.Character:FindFirstChild("HumanoidRootPart"))
    if not Cache.RootPart then return end
    
    local root = target:FindFirstChild("HumanoidRootPart")
    if not root then return end
    
    local dx = Cache.RootPart.Position.X - root.Position.X
    local dy = Cache.RootPart.Position.Y - root.Position.Y
    local dz = Cache.RootPart.Position.Z - root.Position.Z
    if dx * dx + dy * dy + dz * dz > Config.KillAura.MaxDistance ^ 2 then
        removeHighlight(target, "KillAura")
        return
    end
    
    createHighlight(target, "KillAura")
    local serverTarget = target.ServerModel.Value
    if not serverTarget then return end
    
    ToolAction:FireServer("click", serverTarget)
    
    local finalDelay = math.max(0, useRate + 0.1 - Config.KillAura.MinusUseRate)
    task.wait(finalDelay)
    
    if Config.KillAura.AutoRemoveHighlightDelay > 0 then
        task.wait(Config.KillAura.AutoRemoveHighlightDelay)
    end
    
    if Cache.CurrentTarget ~= target then
        removeHighlight(target, "KillAura")
    end
end

local function hitResource(target, item, useRate)
    if not target or not item then
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.AutoMineOreName = nil
            Core.TheApocalypse.AutoMineHealthOre = nil
        end
        return
    end
    
    local config = target:FindFirstChild("Configuration")
    local health = config and config:GetAttribute("Health") or 0
    if health <= 0 then
        if Cache.CurrentResource and Cache.CurrentResource.obj == target then
            Cache.CurrentResource = nil
        end
        removeHighlight(target, "AutoMine")
        removeResourceFromGrid(target)
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.AutoMineOreName = nil
            Core.TheApocalypse.AutoMineHealthOre = nil
        end
        return
    end
    
    createHighlight(target, "AutoMine")
    if Core and Core.TheApocalypse then
        Core.TheApocalypse.AutoMineOreName = target.Name
        Core.TheApocalypse.AutoMineHealthOre = health
    end
    ToolAction:FireServer("click", target, false)
    
    task.wait(useRate)
    
    if Cache.CurrentResource and Cache.CurrentResource.obj ~= target then
        removeHighlight(target, "AutoMine")
    end
end

-- ИСПРАВЛЕННАЯ ФУНКЦИЯ: Проверка, должен ли предмет быть выброшен AutoDrop
local function shouldDropItem(itemName)
    local baseItemName = getBaseItemName(itemName)
    
    -- Если включен ExactModeSync и AutoLoot в режиме Exact
    if Config.AutoDrop.ExactModeSync and Config.AutoLoot.Mode == "Exact" then
        -- В этом режиме мы выкидываем предметы, которые НЕ находятся в списке Exact Items
        local itemsList = Config.AutoLoot.ItemsList
        if type(itemsList) == "table" then
            for item, enabled in pairs(itemsList) do
                if (type(enabled) == "boolean" and enabled and baseItemName == item) or
                   (type(enabled) == "string" and baseItemName == enabled) then
                    return false -- Не выкидываем, так как предмет в списке Exact (мы его оставляем)
                end
            end
        end
        return true -- Выкидываем, так как предмет НЕ в списке Exact
    end
    
    -- Обычная проверка по списку ItemsToDrop (если ExactModeSync не включен)
    local itemsToDrop = Config.AutoDrop.ItemsToDrop
    if type(itemsToDrop) == "table" then
        for item, shouldDrop in pairs(itemsToDrop) do
            if (type(shouldDrop) == "boolean" and shouldDrop and baseItemName == item) or
               (type(shouldDrop) == "string" and baseItemName == shouldDrop) then
                return true
            end
        end
    end
    
    return false
end

local function dropItemsFromInventory()
    if not Config.AutoDrop.Enabled then return end
    
    local currentTime = tick()
    if currentTime - Cache.LastDropCheck < Config.AutoDrop.CheckInterval then
        return
    end
    Cache.LastDropCheck = currentTime
    
    -- Если включена опция OnlyAutoLoot, проверяем был ли недавно лут
    if Config.AutoDrop.OnlyAutoLoot then
        if not Cache.LastLootedItem or currentTime - Cache.LastLootedTime > 10 then
            return
        end
    end
    
    local inventory = LocalPlayer:WaitForChild("Inventory")
    if not inventory then return end
    
    -- Собираем все предметы для дропа
    local itemsToDropNow = {}
    
    for _, itemFolder in ipairs(inventory:GetChildren()) do
        local itemName = itemFolder.Name
        if shouldDropItem(itemName) then
            table.insert(itemsToDropNow, itemFolder)
        end
    end
    
    -- Выкидываем собранные предметы
    for _, itemFolder in ipairs(itemsToDropNow) do
        local args = {
            [1] = itemFolder
        }
        
        DropItem:FireServer(unpack(args))
        task.wait(0.05)
    end
end

local function mainLoop()
    LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        Cache.Character = newCharacter
        Cache.RootPart = nil
        Cache.PlayerPosition = nil
        Cache.CacheValid.Resources = false
        Cache.CacheValid.Loot = false
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.isTargetNear = false
            Core.TheApocalypse.AutoMineOreName = nil
            Core.TheApocalypse.AutoMineHealthOre = nil
            Core.TheApocalypse.AutoLootItemName = nil
        end
    end)
    
    local prevResource = nil
    
    while true do
        Cache.Character = Cache.Character or LocalPlayer.Character
        if not Cache.Character then
            Cache.RootPart = nil
            Cache.PlayerPosition = nil
            if Core and Core.TheApocalypse then
                Core.TheApocalypse.isTargetNear = false
                Core.TheApocalypse.AutoMineOreName = nil
                Core.TheApocalypse.AutoMineHealthOre = nil
                Core.TheApocalypse.AutoLootItemName = nil
            end
            clearKillAuraHighlights(nil)
            clearAutoLootHighlights(nil)
            task.wait(0.1)
            continue
        end
        
        cleanupOldCache()
        
        if Config.KillAura.Enabled then
            local isValid, useRate = isValidWeapon()
            if isValid then
                local target = getNearestTarget()
                clearKillAuraHighlights(target)
                if target then
                    attackTarget(target, useRate)
                else
                    task.wait(0.1)
                end
            else
                clearKillAuraHighlights(nil)
                task.wait(0.1)
            end
        end
        
        if Config.AutoMine.Enabled then
            local item, useRate = findPlayerItem()
            if item then
                if Config.AutoMine.ZombieAlert_Enabled and checkZombieAlert() then
                    if prevResource then
                        removeHighlight(prevResource, "AutoMine")
                        prevResource = nil
                    end
                    if Core and Core.TheApocalypse then
                        Core.TheApocalypse.AutoMineOreName = nil
                        Core.TheApocalypse.AutoMineHealthOre = nil
                    end
                    task.wait(Config.AutoMine.CheckInterval)
                else
                    local resource = findNearestResource()
                    if resource then
                        if prevResource and prevResource ~= resource then
                            removeHighlight(prevResource, "AutoMine")
                        end
                        hitResource(resource, item, useRate)
                        prevResource = resource
                    else
                        if prevResource then
                            removeHighlight(prevResource, "AutoMine")
                            prevResource = nil
                        end
                        if Core and Core.TheApocalypse then
                            Core.TheApocalypse.AutoMineOreName = nil
                            Core.TheApocalypse.AutoMineHealthOre = nil
                        end
                        task.wait(Config.AutoMine.CheckInterval)
                    end
                end
            else
                if prevResource then
                    removeHighlight(prevResource, "AutoMine")
                    prevResource = nil
                end
                if Core and Core.TheApocalypse then
                    Core.TheApocalypse.AutoMineOreName = nil
                    Core.TheApocalypse.AutoMineHealthOre = nil
                end
                task.wait(Config.AutoMine.CheckInterval)
            end
        else
            if prevResource then
                removeHighlight(prevResource, "AutoMine")
                prevResource = nil
            end
        end
        
        if Config.AutoLoot.Enabled then
            local data = LocalPlayer:WaitForChild("Data")
            local inventory = LocalPlayer:WaitForChild("Inventory")
            local inventorySize = data:WaitForChild("InventorySize")
            if not inventory or not inventorySize then
                task.wait(0.1)
                continue
            end
            
            local maxSlots = inventorySize.Value
            if maxSlots <= 0 then
                task.wait(0.1)
                continue
            end
            
            local currentTime = tick()
            if currentTime - Cache.LastLootCheck < Config.AutoLoot.CheckInterval then
                task.wait(0.1)
                continue
            end
            Cache.LastLootCheck = currentTime
            
            local lootItem, itemName, lootModel = findNearestLoot()
            if not lootItem or not itemName then
                task.wait(0.1)
                continue
            end
            
            local countValue = lootItem:FindFirstChild("Count")
            local lootCount = countValue and countValue.Value or 1
            local baseItemName = getBaseItemName(itemName)
            local itemConfig = getItemConfig(baseItemName)
            local playerItemFolder, existingSlot = findExistingItemFolder(inventory, itemName, lootItem)
            
            if playerItemFolder then
                local playerCountValue = playerItemFolder:FindFirstChild("Count")
                local playerCount = playerCountValue and playerCountValue.Value or 0
                if playerCount < itemConfig.maxStack then
                    local args = {
                        [1] = lootItem,
                        [2] = playerItemFolder
                    }
                    MergeItems:FireServer(unpack(args))
                    Cache.LastLootedItem = itemName
                    Cache.LastLootedTime = currentTime
                    task.wait(Config.AutoLoot.ActionDelay)
                end
            else
                local freeSlot = findFreeSlot(inventory, maxSlots)
                if freeSlot and (Config.AutoLoot.UseFreeSlotWhileWaiting or not findExistingItemFolder(inventory, itemName, lootItem)) then
                    local args = {
                        [1] = lootItem,
                        [2] = "Inventory",
                        [3] = freeSlot
                    }
                    MoveItem:FireServer(unpack(args))
                    Cache.LastLootedItem = itemName
                    Cache.LastLootedTime = currentTime
                    task.wait(Config.AutoLoot.ActionDelay)
                else
                    if itemConfig.maxStack > 1 then
                        for _, itemFolder in ipairs(inventory:GetChildren()) do
                            if getBaseItemName(itemFolder.Name) == baseItemName then
                                local countValue = itemFolder:FindFirstChild("Count")
                                local indexValue = itemFolder:FindFirstChild("Index")
                                if countValue and indexValue and countValue.Value < itemConfig.maxStack and itemFolder ~= lootItem and itemFolder.Parent then
                                    local args = {
                                        [1] = lootItem,
                                        [2] = itemFolder
                                    }
                                    MergeItems:FireServer(unpack(args))
                                    Cache.LastLootedItem = itemName
                                    Cache.LastLootedTime = currentTime
                                    task.wait(Config.AutoLoot.ActionDelay)
                                    break
                                end
                            end
                        end
                    end
                end
            end
        end
        
        dropItemsFromInventory()
        
        task.wait(0.05)
    end
end

local function initializeItemCache()
    for _, itemModel in ipairs(Items:GetChildren()) do
        getItemConfig(itemModel.Name)
    end
end

Spawned.ChildAdded:Connect(function(child)
    if child:IsA("Model") and child.Parent and child.PrimaryPart then
        local lootTypes = getLootTypes()
        
        if lootTypes[child.Name] then
            if Config.AutoLoot.Enabled then
                task.spawn(function()
                    task.wait(0.1)
                    local inventoryFolder = child:FindFirstChild("Inventory")
                    if inventoryFolder then
                        local items = {}
                        for _, itemFolder in ipairs(inventoryFolder:GetChildren()) do
                            if isItemAllowed(itemFolder.Name) then
                                table.insert(items, itemFolder)
                            end
                        end
                        if #items > 0 then
                            addLootToGrid(child, child.PrimaryPart.Position, items)
                            if Config.AutoLoot.HighlightEnabled then
                                createHighlight(child, "AutoLoot")
                            end
                        end
                    end
                end)
            end
        else
            if Config.AutoMine.Enabled then
                table.insert(Cache.PendingResources, child)
            end
        end
    end
end)

Spawned.ChildRemoved:Connect(function(child)
    if Cache.CurrentResource and Cache.CurrentResource.obj == child then
        Cache.CurrentResource = nil
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.AutoMineOreName = nil
            Core.TheApocalypse.AutoMineHealthOre = nil
        end
    end
    if Cache.LootCache[child] then
        if Cache.CurrentLoot == child then
            removeHighlight(Cache.CurrentLoot, "AutoLoot")
            Cache.CurrentLoot = nil
            if Core and Core.TheApocalypse then
                Core.TheApocalypse.AutoLootItemName = nil
            end
        end
        removeLootFromGrid(child)
    end
    removeResourceFromGrid(child)
    removeHighlight(child, "AutoMine")
    removeHighlight(child, "AutoLoot")
end)

Enemies.ChildRemoved:Connect(function(child)
    if Cache.CurrentTarget and Cache.CurrentTarget == child then
        Cache.CurrentTarget = nil
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.isTargetNear = false
        end
    end
    removeHighlight(child, "KillAura")
end)

local function initializeUI(UI)
    if UI.Tabs and UI.Tabs.Main then
        local killAuraSection = UI.Tabs.Main:Section({ Name = "KillAura", Side = "Right" })
        killAuraSection:Header({ Name = "KillAura" })
        killAuraSection:SubLabel({ Text = "Automates melee attacks on nearby enemies" })
        
        uiElements.KillAuraEnabled = killAuraSection:Toggle({
            Name = "Enabled",
            Default = Config.KillAura.Enabled,
            Callback = function(value)
                Config.KillAura.Enabled = value
                if not value then clearKillAuraHighlights(nil) end
                notify("KillAura", "KillAura " .. (value and "Enabled" or "Disabled"), true)
            end
        }, 'KillAuraEnabled')
        
        uiElements.KillAuraMaxDistance = killAuraSection:Slider({
            Name = "Max Distance",
            Minimum = 5,
            Maximum = 30,
            Default = Config.KillAura.MaxDistance,
            Precision = 1,
            Callback = function(value)
                Config.KillAura.MaxDistance = value
                clearKillAuraHighlights(Cache.CurrentTarget)
                notify("KillAura", "Max Distance set to: " .. value, false)
            end
        }, 'KillAuraMaxDistance')
        
        uiElements.KillAuraHighlightEnabled = killAuraSection:Toggle({
            Name = "Highlight Enabled",
            Default = Config.KillAura.HighlightEnabled,
            Callback = function(value)
                Config.KillAura.HighlightEnabled = value
                if not value then clearKillAuraHighlights(nil) end
                notify("KillAura", "Highlight " .. (value and "Enabled" or "Disabled"), true)
            end
        }, 'KillAuraHighlightEnabled')
        
        uiElements.KillAuraHighlightColor = killAuraSection:Colorpicker({
            Name = "Highlight Color",
            Default = Config.KillAura.HighlightColor,
            Callback = function(value)
                Config.KillAura.HighlightColor = value
                notify("KillAura", "Highlight Color updated", false)
            end
        }, 'KillAuraHighlightColor')
        killAuraSection:Divider()
        uiElements.KillAuraMinusUseRate = killAuraSection:Slider({
            Name = "Minus UseRate",
            Minimum = 0,
            Maximum = 0.5,
            Default = Config.KillAura.MinusUseRate,
            Precision = 2,
            Callback = function(value)
                Config.KillAura.MinusUseRate = value
                notify("KillAura", "Minus Use Rate set to: " .. value, false)
            end
        }, 'KillAuraMinusUseRate')
        killAuraSection:SubLabel({ Text = "[ ⁉️ ] Reduces the delay before the next KillAura attack" })
        killAuraSection:Divider()
        
        local autoMineSection = UI.Tabs.Main:Section({ Name = "AutoMine", Side = "Left" })
        autoMineSection:Header({ Name = "AutoMine" })
        autoMineSection:SubLabel({ Text = "Automates resource farm" })
        
        uiElements.AutoMineEnabled = autoMineSection:Toggle({
            Name = "Enabled",
            Default = Config.AutoMine.Enabled,
            Callback = function(value)
                Config.AutoMine.Enabled = value
                notify("AutoMine", "AutoMine " .. (value and "Enabled" or "Disabled"), true)
            end
        }, 'AutoMineEnabled')
        
        uiElements.AutoMineDistanceLimit = autoMineSection:Slider({
            Name = "Max Distance",
            Minimum = 20,
            Maximum = 1500,
            Default = Config.AutoMine.DistanceLimit,
            Precision = 0,
            Callback = function(value)
                Config.AutoMine.DistanceLimit = value
                Cache.CacheValid.Resources = false
                notify("AutoMine", "Max Distance set to: " .. value, false)
            end
        }, 'AutoMineDistanceLimit')
        autoMineSection:Divider()
        uiElements.AutoMineCheckInterval = autoMineSection:Slider({
            Name = "Check Interval",
            Minimum = 0.1,
            Maximum = 0.5,
            Default = Config.AutoMine.CheckInterval,
            Precision = 2,
            Callback = function(value)
                Config.AutoMine.CheckInterval = value
                notify("AutoMine", "Check Interval set to: " .. value, false)
            end
        }, 'AutoMineCheckInterval')
        autoMineSection:Divider()
        uiElements.AutoMineHighlightEnabled = autoMineSection:Toggle({
            Name = "Highlight Enabled",
            Default = Config.AutoMine.HighlightEnabled,
            Callback = function(value)
                Config.AutoMine.HighlightEnabled = value
                notify("AutoMine", "Highlight " .. (value and "Enabled" or "Disabled"), true)
            end
        }, 'AutoMineHighlightEnabled')
        
        uiElements.AutoMineHighlightColor = autoMineSection:Colorpicker({
            Name = "Highlight Color",
            Default = Config.AutoMine.HighlightColor,
            Callback = function(value)
                Config.AutoMine.HighlightColor = value
                notify("AutoMine", "Highlight Color updated", false)
            end
        }, 'AutoMineHighlightColor')
        
        uiElements.AutoMineMode = autoMineSection:Dropdown({
            Name = "Mode",
            Default = Config.AutoMine.Mode,
            Options = { "All", "Tree", "Stone", "Coal", "IronOre", "CopperOre", "Palm", "Sandstone" },
            Search = true,
            Callback = function(value)
                Config.AutoMine.Mode = value
                Cache.CacheValid.Resources = false
                notify("AutoMine", "Mode set to: " .. value, false)
            end
        }, 'AutoMineMode')
        
        uiElements.AutoMinePrioritizeResources = autoMineSection:Dropdown({
            Name = "Prioritize Resources",
            Default = Config.AutoMine.PrioritizeResources,
            Options = { "None", "Trees", "Stones", "Ores" },
            Search = true,
            Callback = function(value)
                Config.AutoMine.PrioritizeResources = value
                notify("AutoMine", "Prioritize Resources set to: " .. value, false)
            end
        }, 'AutoMinePrioritizeResources')
        autoMineSection:Divider()
        uiElements.AutoMineZombieAlertEnabled = autoMineSection:Toggle({
            Name = "Zombie Alert",
            Default = Config.AutoMine.ZombieAlert_Enabled,
            Callback = function(value)
                Config.AutoMine.ZombieAlert_Enabled = value
                notify("AutoMine", "Zombie Alert " .. (value and "Enabled" or "Disabled"), true)
            end
        }, 'AutoMineZombieAlertEnabled')
        autoMineSection:SubLabel({ Text = "[ ⁉️ ] Stops farming resources when an enemy is nearby" })
        uiElements.AutoMineZombieAlertRadius = autoMineSection:Slider({
            Name = "Alert Radius",
            Minimum = 20,
            Maximum = 100,
            Default = Config.AutoMine.ZombieAlert_Radius,
            Precision = 0,
            Callback = function(value)
                Config.AutoMine.ZombieAlert_Radius = value
                notify("AutoMine", "Zombie Alert Radius set to: " .. value, false)
            end
        }, 'AutoMineZombieAlertRadius')
        autoMineSection:Divider()
        uiElements.AutoMineGridCellSize = autoMineSection:Slider({
            Name = "GridCellSize",
            Minimum = 25,
            Maximum = 250,
            Default = Config.AutoMine.GridCellSize,
            Precision = 0,
            Callback = function(value)
                Config.AutoMine.GridCellSize = value
                Cache.CacheValid.Resources = false
                notify("AutoMine", "Grid Cell Size set to: " .. value, false)
            end
        }, 'AutoMineGridCellSize')
        autoMineSection:SubLabel({ Text = "[❗] Not recommend to change" })
        
        local autoLootSection = UI.Tabs.Main:Section({ Name = "AutoLoot", Side = "Right" })
        autoLootSection:Header({ Name = "AutoLoot" })
        autoLootSection:SubLabel({ Text = "Automates loot collection from crates" })
        
        uiElements.AutoLootEnabled = autoLootSection:Toggle({
            Name = "Enabled",
            Default = Config.AutoLoot.Enabled,
            Callback = function(value)
                Config.AutoLoot.Enabled = value
                if not value then
                    clearAutoLootHighlights(nil)
                    if Core and Core.TheApocalypse then
                        Core.TheApocalypse.AutoLootItemName = nil
                    end
                else
                    Cache.CacheValid.Loot = false
                end
                notify("AutoLoot", "AutoLoot " .. (value and "Enabled" or "Disabled"), true)
            end
        })
        
        uiElements.AutoLootMaxDistance = autoLootSection:Slider({
            Name = "Max Distance",
            Minimum = 20,
            Maximum = 1500,
            Default = Config.AutoLoot.MaxDistance,
            Precision = 0,
            Callback = function(value)
                Config.AutoLoot.MaxDistance = value
                Cache.CacheValid.Loot = false
                notify("AutoLoot", "Max Distance set to: " .. value, false)
            end
        })
        autoLootSection:Divider()
        
        uiElements.AutoLootCheckInterval = autoLootSection:Slider({
            Name = "Check Interval",
            Minimum = 0.1,
            Maximum = 1.0,
            Default = Config.AutoLoot.CheckInterval,
            Precision = 2,
            Callback = function(value)
                Config.AutoLoot.CheckInterval = value
                notify("AutoLoot", "Check Interval set to: " .. value, false)
            end
        })
        autoLootSection:Divider()
        
        uiElements.AutoLootValidationDelay = autoLootSection:Slider({
            Name = "Validation Delay",
            Minimum = 0.1,
            Maximum = 2,
            Default = Config.AutoLoot.ValidationDelay,
            Precision = 1,
            Callback = function(value)
                Config.AutoLoot.ValidationDelay = value
                notify("AutoLoot", "Validation Delay set to: " .. value, false)
            end
        })
        autoLootSection:SubLabel({ Text = "[ ⁉️ ] Delay for validating items in inventory" })
        autoLootSection:Divider()
        
        uiElements.AutoLootHighlightEnabled = autoLootSection:Toggle({
            Name = "Highlight Enabled",
            Default = Config.AutoLoot.HighlightEnabled,
            Callback = function(value)
                Config.AutoLoot.HighlightEnabled = value
                if not value then
                    clearAutoLootHighlights(nil)
                    if Core and Core.TheApocalypse then
                        Core.TheApocalypse.AutoLootItemName = nil
                    end
                end
                notify("AutoLoot", "Highlight " .. (value and "Enabled" or "Disabled"), true)
            end
        })
        
        uiElements.AutoLootHighlightColor = autoLootSection:Colorpicker({
            Name = "Highlight Color",
            Default = Config.AutoLoot.HighlightColor,
            Callback = function(value)
                Config.AutoLoot.HighlightColor = value
                notify("AutoLoot", "Highlight Color updated", false)
            end
        })
        autoLootSection:Divider()
        
        uiElements.AutoLootMode = autoLootSection:Dropdown({
            Name = "Mode",
            Default = Config.AutoLoot.Mode,
            Options = { "None", "Exact", "Exclude" },
            Search = true,
            Callback = function(value)
                Config.AutoLoot.Mode = value
                Cache.CacheValid.Loot = false
                notify("AutoLoot", "Mode set to: " .. value, false)
            end
        })
        autoLootSection:SubLabel({ Text = "[ ⁉️ ] None: All items, Exact: Only selected, Exclude: All except selected" })
        
        uiElements.AutoLootLootCrates = autoLootSection:Dropdown({
            Name = "Loot Crates",
            Default = Config.AutoLoot.LootCrates,
            Options = { "All", "CommonLoot", "RareLoot", "UncommonLoot" },
            Search = true,
            Multi = true,
            Callback = function(value)
                Config.AutoLoot.LootCrates = value
                Cache.CacheValid.Loot = false
                notify("AutoLoot", "Loot Crates updated", false)
            end
        })
        
        local itemOptions = {}
        for _, item in ipairs(Items:GetChildren()) do
            local itemConfig = getItemConfig(item.Name)
            if itemConfig.class == "consumable" or itemConfig.class == "resource" then
                table.insert(itemOptions, item.Name)
            end
        end
        table.sort(itemOptions)
        
        uiElements.AutoLootItemsList = autoLootSection:Dropdown({
            Name = "Items List",
            Default = Config.AutoLoot.ItemsList,
            Options = itemOptions,
            Search = true,
            Multi = true,
            Callback = function(value)
                Config.AutoLoot.ItemsList = value
                Cache.CacheValid.Loot = false
                notify("AutoLoot", "Items List updated", false)
            end
        })
        autoLootSection:SubLabel({ Text = "[ ⁉️ ] Select items for Exact or Exclude mode" })
        
        local autoDropSection = UI.Tabs.Main:Section({ Name = "AutoDrop", Side = "Left" })
        autoDropSection:Header({ Name = "AutoDrop" })
        autoDropSection:SubLabel({ Text = "Automatically drops selected items from inventory" })
        
        uiElements.AutoDropEnabled = autoDropSection:Toggle({
            Name = "Enabled",
            Default = Config.AutoDrop.Enabled,
            Callback = function(value)
                Config.AutoDrop.Enabled = value
                notify("AutoDrop", "AutoDrop " .. (value and "Enabled" or "Disabled"), true)
            end
        })
        
        uiElements.AutoDropOnlyAutoLoot = autoDropSection:Toggle({
            Name = "Only AutoLoot",
            Default = Config.AutoDrop.OnlyAutoLoot,
            Callback = function(value)
                Config.AutoDrop.OnlyAutoLoot = value
                notify("AutoDrop", "Only AutoLoot " .. (value and "Enabled" or "Disabled"), true)
            end
        })
        
        uiElements.AutoDropExactModeSync = autoDropSection:Toggle({
            Name = "Exact Mode Sync",
            Default = Config.AutoDrop.ExactModeSync,
            Callback = function(value)
                Config.AutoDrop.ExactModeSync = value
                notify("AutoDrop", "Exact Mode Sync " .. (value and "Enabled" or "Disabled"), true)
            end
        })
        autoDropSection:SubLabel({ Text = "[ ⁉️ ] When enabled, AutoLoot (Exact mode) collects ALL items, AutoDrop drops items NOT in the Exact list" })
        
        uiElements.AutoDropCheckInterval = autoDropSection:Slider({
            Name = "Check Interval",
            Minimum = 0.5,
            Maximum = 5.0,
            Default = Config.AutoDrop.CheckInterval,
            Precision = 1,
            Callback = function(value)
                Config.AutoDrop.CheckInterval = value
                notify("AutoDrop", "Check Interval set to: " .. value, false)
            end
        })
        
        uiElements.AutoDropItemsList = autoDropSection:Dropdown({
            Name = "Items to Drop",
            Default = Config.AutoDrop.ItemsToDrop,
            Options = itemOptions, -- Используем тот же список что и для AutoLoot
            Search = true,
            Multi = true,
            Callback = function(value)
                Config.AutoDrop.ItemsToDrop = value
                notify("AutoDrop", "Items to Drop updated", false)
            end
        })
        autoDropSection:SubLabel({ Text = "[ ⁉️ ] Only AutoLoot: Drop only after AutoLoot picks up items" })
    end
end

initializeItemCache()

task.spawn(mainLoop)

local function init(UI, core, notif)
    Core = core
    notify = notif or print
    if Core then
        Core.TheApocalypse = {
            isTargetNear = false,
            AutoMineOreName = nil,
            AutoMineHealthOre = nil,
            AutoLootItemName = nil
        }
    end
    if UI then
        initializeUI(UI)
        
        -- Запускаем автоматическую синхронизацию конфигурации
        local synchronizationTimer = 0
        RunService.Heartbeat:Connect(function(deltaTime)
            synchronizationTimer = synchronizationTimer + deltaTime
            
            if synchronizationTimer >= 1.0 then
                synchronizationTimer = 0
                SynchronizeConfigValues()
            end
        end)
    end
end

return { Init = init }
