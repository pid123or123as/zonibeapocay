local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local Enemies = Workspace:WaitForChild("Enemies")
local Spawned = Workspace:WaitForChild("Spawned")
local Network = ReplicatedStorage:WaitForChild("Network")
local ItemsFolder = Network:WaitForChild("Items")
local ToolAction = ItemsFolder:WaitForChild("ToolAction")
local MoveItem = ItemsFolder:WaitForChild("MoveItem")
local MergeItems = ItemsFolder:WaitForChild("MergeItems")
local Items = ReplicatedStorage:WaitForChild("Items")
local MeleeModule = require(ReplicatedStorage.Modules.ToolHandlers.Melee)
local Camera = Workspace.CurrentCamera
local Inventory = LocalPlayer:WaitForChild("Inventory")

local Config = {
    KillAura = {
        Enabled = false,
        MaxDistance = 30,
        HighlightColor = Color3.fromRGB(255, 0, 0),
        HighlightTransparency = 0.5,
        HighlightEnabled = true,
        MinusUseRate = 0.0,
        AutoRemoveHighlightDelay = 0
    },
    AutoMine = {
        Enabled = false,
        DistanceLimit = 200,
        CheckInterval = 0.5,
        HighlightEnabled = true,
        HighlightColor = Color3.fromRGB(0, 255, 0),
        HighlightTransparency = 0.5,
        MinusUseRate = 0.7,
        DefaultUseRate = 0.85,
        Mode = "All",
        PrioritizeResources = "Stones",
        ZombieAlert_Enabled = true,
        ZombieAlert_Radius = 25,
        CacheUpdateInterval = 2.0,
        GridCellSize = 150,
        PositionUpdateThreshold = 5
    },
    AutoLoot = {
        Enabled = false,
        MaxDistance = 100,
        CheckInterval = 0.5,
        LootCacheUpdateInterval = 2.0,
        InventoryCheckInterval = 0.2,
        GridCellSize = 200,
        HighlightEnabled = true,
        HighlightColor = Color3.fromRGB(0, 255, 255),
        HighlightTransparency = 0.5,
        Mode = "None",
        LootCrates = { "All" },
        ItemsList = {},
        ActionDelay = 0.5,
        UseFreeSlotWhileWaiting = true,
        ValidationDelay = 0.1,
        PositionUpdateThreshold = 5
    }
}

local PRIORITY_GROUPS = {
    Trees = { Tree = true, Palm = true },
    Stones = { Stone = true, Coal = true, IronOre = true, CopperOre = true, Sandstone = true },
    Ores = { IronOre = true, CopperOre = true }
}

local VALID_RESOURCE_TYPES = {
    Tree = true,
    Palm = true,
    Stone = true,
    Coal = true,
    IronOre = true,
    CopperOre = true,
    Sandstone = true
}

local function getLootTypes()
    local lootTypes = {
        CommonLoot = false,
        RareLoot = false,
        UncommonLoot = false
    }
    for _, crate in ipairs(Config.AutoLoot.LootCrates) do
        if crate == "All" then
            lootTypes.CommonLoot = true
            lootTypes.RareLoot = true
            lootTypes.UncommonLoot = true
            break
        elseif crate == "Common" then
            lootTypes.CommonLoot = true
        elseif crate == "Rare" then
            lootTypes.RareLoot = true
        elseif crate == "Uncommon" then
            lootTypes.UncommonLoot = true
        end
    end
    return lootTypes
end

local Cache = {
    CurrentTarget = nil,
    LastTargetCheck = 0,
    TargetCheckInterval = 0.1,
    CurrentResource = nil,
    LastResourceCheck = 0,
    LastCacheUpdate = 0,
    Character = nil,
    RootPart = nil,
    PlayerPosition = nil,
    LastPositionUpdate = 0,
    ResourceGrid = {},
    PendingResources = {},
    CacheValid = { Resources = false, Loot = false },
    CurrentLoot = nil,
    LastLootCheck = 0,
    LastLootCacheUpdate = 0,
    LastInventoryCheck = 0,
    LootGrid = {},
    LootCache = {},
    ItemConfigs = {},
    InventoryTimestamps = {},
    InventoryCache = {}
}

local Highlights = {
    KillAura = {},
    AutoMine = {},
    AutoLoot = {}
}

local uiElements = {}

local notify = print

local Core = nil

local function createHighlight(target, mode)
    local highlightTable = mode == "AutoMine" and Highlights.AutoMine or mode == "AutoLoot" and Highlights.AutoLoot or Highlights.KillAura
    local config = mode == "AutoMine" and Config.AutoMine or mode == "AutoLoot" and Config.AutoLoot or Config.KillAura
    if config.HighlightEnabled and not highlightTable[target] then
        local highlight = Instance.new("Highlight")
        highlight.Adornee = target
        highlight.FillColor = config.HighlightColor
        highlight.FillTransparency = config.HighlightTransparency
        highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
        highlight.OutlineTransparency = 0
        highlight.Parent = target
        highlightTable[target] = highlight
    end
end

local function removeHighlight(target, mode)
    local highlightTable = mode == "AutoMine" and Highlights.AutoMine or mode == "AutoLoot" and Highlights.AutoLoot or Highlights.KillAura
    if highlightTable[target] then
        highlightTable[target]:Destroy()
        highlightTable[target] = nil
    end
end

local function clearKillAuraHighlights(currentTarget)
    for target, highlight in pairs(Highlights.KillAura) do
        if target ~= currentTarget then
            removeHighlight(target, "KillAura")
        end
    end
end

local function clearAutoLootHighlights(currentLoot)
    for target, highlight in pairs(Highlights.AutoLoot) do
        if target ~= currentLoot then
            removeHighlight(target, "AutoLoot")
        end
    end
end

local function isValidWeapon()
    Cache.Character = Cache.Character or LocalPlayer.Character
    if not Cache.Character then return false end
    
    local item = Cache.Character:FindFirstChild("Item")
    if not item then return false end
    
    local model = item:FindFirstChildWhichIsA("Model")
    if not model then return false end
    
    local config = model:FindFirstChild("Config")
    local meleeConfig = model:FindFirstChild("MeleeConfig")
    if not config or not meleeConfig then return false end
    
    local configData = require(config)
    if configData.toolType ~= "Melee" or not configData.useRate then
        return false
    end
    
    return true, configData.useRate
end

local function findPlayerItem()
    Cache.Character = Cache.Character or LocalPlayer.Character
    if not Cache.Character then return nil, Config.AutoMine.DefaultUseRate end
    
    local vm = Camera:FindFirstChild("VM")
    if not vm then return nil, Config.AutoMine.DefaultUseRate end
    
    local item = vm:FindFirstChildWhichIsA("Tool")
    if not item then return nil, Config.AutoMine.DefaultUseRate end
    
    local model = item:FindFirstChildWhichIsA("Model")
    if not model then return nil, Config.AutoMine.DefaultUseRate end
    
    local configModule = model:FindFirstChild("Config")
    if not configModule or not configModule:IsA("ModuleScript") then
        return nil, Config.AutoMine.DefaultUseRate
    end
    
    local success, configTable = pcall(require, configModule)
    if not success or not configTable or configTable.class ~= "tool" then
        return nil, Config.AutoMine.DefaultUseRate
    end
    
    local meleeConfig = model:FindFirstChild("MeleeConfig")
    local gunConfig = model:FindFirstChild("GunConfig")
    if meleeConfig or gunConfig then
        return nil, Config.AutoMine.DefaultUseRate
    end
    
    local useRate = configTable.useRate or Config.AutoMine.DefaultUseRate
    return item, math.max(0.1, useRate - Config.AutoMine.MinusUseRate)
end

local function getBaseItemName(itemName)
    return itemName:match("^[^_]+") or itemName
end

local function getItemConfig(itemName)
    if Cache.ItemConfigs[itemName] then
        return Cache.ItemConfigs[itemName]
    end
    
    local itemModel = Items:FindFirstChild(itemName)
    local config = { maxStack = 1, class = nil }
    
    if itemModel then
        local configModule = itemModel:FindFirstChild("Config")
        if configModule and configModule:IsA("ModuleScript") then
            local success, configTable = pcall(require, configModule)
            if success and configTable then
                config.maxStack = configTable.maxStack or 1
                if config.maxStack == false or config.maxStack == nil then
                    config.maxStack = 1
                elseif type(config.maxStack) ~= "number" then
                    config.maxStack = 1
                end
                config.class = configTable.class or nil
            end
        end
    end
    
    Cache.ItemConfigs[itemName] = config
    return config
end

local function isItemAllowed(itemName)
    local baseItemName = getBaseItemName(itemName)
    if Config.AutoLoot.Mode == "None" then
        return true
    elseif Config.AutoLoot.Mode == "Exact" then
        for item, enabled in pairs(Config.AutoLoot.ItemsList) do
            if enabled and baseItemName == item then
                return true
            end
        end
        return false
    elseif Config.AutoLoot.Mode == "Exclude" then
        for item, enabled in pairs(Config.AutoLoot.ItemsList) do
            if enabled and baseItemName == item then
                return false
            end
        end
        return true
    end
    return true
end

local function findFreeSlot(inventory, maxSlots)
    for slot = 1, maxSlots do
        local slotTaken = false
        for _, itemFolder in ipairs(inventory:GetChildren()) do
            local indexValue = itemFolder:FindFirstChild("Index")
            if indexValue and indexValue.Value == slot then
                slotTaken = true
                break
            end
        end
        if not slotTaken then
            return slot
        end
    end
    return nil
end

local function findExistingItemFolder(inventory, itemName, lootItem)
    local currentTime = tick()
    if currentTime - Cache.LastInventoryCheck < Config.AutoLoot.InventoryCheckInterval then
        local cachedResult = Cache.InventoryCache[itemName]
        if cachedResult then
            return cachedResult.folder, cachedResult.slot
        end
    end
    
    local baseItemName = getBaseItemName(itemName)
    local itemConfig = getItemConfig(baseItemName)
    local maxStack = itemConfig.maxStack
    
    if maxStack <= 1 then
        return nil, nil
    end
    
    for _, itemFolder in ipairs(inventory:GetChildren()) do
        if getBaseItemName(itemFolder.Name) == baseItemName then
            local countValue = itemFolder:FindFirstChild("Count")
            local indexValue = itemFolder:FindFirstChild("Index")
            if countValue and indexValue and itemFolder ~= lootItem then
                if countValue.Value < maxStack then
                    local timestamp = Cache.InventoryTimestamps[itemFolder] or 0
                    if currentTime - timestamp >= Config.AutoLoot.ValidationDelay then
                        Cache.InventoryCache[itemName] = { folder = itemFolder, slot = indexValue.Value }
                        Cache.LastInventoryCheck = currentTime
                        return itemFolder, indexValue.Value
                    end
                end
            end
        end
    end
    Cache.InventoryCache[itemName] = nil
    Cache.LastInventoryCheck = currentTime
    return nil, nil
end

local function getGridKey(pos)
    local cellSize = Config.AutoLoot.GridCellSize
    local x = math.floor(pos.X / cellSize)
    local y = math.floor(pos.Y / cellSize)
    local z = math.floor(pos.Z / cellSize)
    return x .. "," .. y .. "," .. z
end

local function addLootToGrid(lootModel, pos, items)
    if not lootModel:IsA("Model") or not lootModel.Parent or not lootModel.PrimaryPart then return end
    local key = getGridKey(pos)
    Cache.LootGrid[key] = Cache.LootGrid[key] or {}
    Cache.LootGrid[key][lootModel] = { items = items, position = pos }
    Cache.LootCache[lootModel] = { items = items, position = pos }
end

local function removeLootFromGrid(lootModel)
    for key, cell in pairs(Cache.LootGrid) do
        if cell[lootModel] then
            cell[lootModel] = nil
            if next(cell) == nil then
                Cache.LootGrid[key] = nil
            end
        end
    end
    Cache.LootCache[lootModel] = nil
end

local function initializeLootCache()
    Cache.LootGrid = {}
    Cache.LootCache = {}
    local lootTypes = getLootTypes()
    for _, lootModel in ipairs(Spawned:GetChildren()) do
        if lootTypes[lootModel.Name] and lootModel:IsA("Model") and lootModel.Parent and lootModel.PrimaryPart then
            local inventoryFolder = lootModel:FindFirstChild("Inventory")
            if inventoryFolder then
                local items = {}
                for _, itemFolder in ipairs(inventoryFolder:GetChildren()) do
                    if isItemAllowed(itemFolder.Name) then
                        table.insert(items, itemFolder)
                    end
                end
                if #items > 0 then
                    addLootToGrid(lootModel, lootModel.PrimaryPart.Position, items)
                    if Config.AutoLoot.Enabled then
                        createHighlight(lootModel, "AutoLoot")
                    end
                end
            end
        end
    end
    Cache.CacheValid.Loot = true
    Cache.LastLootCacheUpdate = tick()
end

local function findNearestLoot()
    Cache.Character = Cache.Character or LocalPlayer.Character
    if not Cache.Character then
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.AutoLootItemName = nil
        end
        return nil, nil, nil
    end
    
    Cache.RootPart = Cache.RootPart or Cache.Character:FindFirstChild("HumanoidRootPart")
    if not Cache.RootPart then
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.AutoLootItemName = nil
        end
        return nil, nil, nil
    end
    
    local currentTime = tick()
    local playerPos = Cache.RootPart.Position
    if Cache.PlayerPosition and (currentTime - Cache.LastPositionUpdate < Config.AutoLoot.CheckInterval) then
        local dx = playerPos.X - Cache.PlayerPosition.X
        local dy = playerPos.Y - Cache.PlayerPosition.Y
        local dz = playerPos.Z - Cache.PlayerPosition.Z
        if dx * dx + dy * dy + dz * dz < Config.AutoLoot.PositionUpdateThreshold ^ 2 then
            playerPos = Cache.PlayerPosition
        else
            Cache.PlayerPosition = playerPos
            Cache.LastPositionUpdate = currentTime
        end
    else
        Cache.PlayerPosition = playerPos
        Cache.LastPositionUpdate = currentTime
    end
    
    if currentTime - Cache.LastLootCacheUpdate > Config.AutoLoot.LootCacheUpdateInterval or not Cache.CacheValid.Loot then
        initializeLootCache()
    end
    
    local nearestLoot, nearestItem, nearestModel, minDistanceSqr = nil, nil, nil, math.huge
    local maxDistanceSqr = Config.AutoLoot.MaxDistance ^ 2
    local cellSize = Config.AutoLoot.GridCellSize
    local gridRadius = math.ceil(Config.AutoLoot.MaxDistance / cellSize) + 1
    local playerX, playerY, playerZ = math.floor(playerPos.X / cellSize), math.floor(playerPos.Y / cellSize), math.floor(playerPos.Z / cellSize)
    local gridCells = {}
    for x = playerX - gridRadius, playerX + gridRadius do
        for y = playerY - gridRadius, playerY + gridRadius do
            for z = playerZ - gridRadius, playerZ + gridRadius do
                table.insert(gridCells, x .. "," .. y .. "," .. z)
            end
        end
    end
    
    for _, key in ipairs(gridCells) do
        local cell = Cache.LootGrid[key]
        if cell then
            for lootModel, data in pairs(cell) do
                if lootModel.Parent and lootModel.PrimaryPart then
                    local dx = playerPos.X - data.position.X
                    local dy = playerPos.Y - data.position.Y
                    local dz = playerPos.Z - data.position.Z
                    local distSqr = dx * dx + dy * dy + dz * dz
                    if distSqr <= maxDistanceSqr and distSqr < minDistanceSqr then
                        for _, itemFolder in ipairs(data.items) do
                            if itemFolder.Parent and itemFolder.Parent.Parent == lootModel then
                                nearestLoot = itemFolder
                                nearestItem = itemFolder.Name
                                nearestModel = lootModel
                                minDistanceSqr = distSqr
                                break
                            end
                        end
                    end
                else
                    removeLootFromGrid(lootModel)
                    removeHighlight(lootModel, "AutoLoot")
                end
            end
        end
    end
    
    if nearestLoot and Config.AutoLoot.Enabled then
        if Cache.CurrentLoot and Cache.CurrentLoot ~= nearestModel then
            removeHighlight(Cache.CurrentLoot, "AutoLoot")
        end
        Cache.CurrentLoot = nearestModel
        createHighlight(Cache.CurrentLoot, "AutoLoot")
    elseif Cache.CurrentLoot then
        removeHighlight(Cache.CurrentLoot, "AutoLoot")
        Cache.CurrentLoot = nil
    end
    
    if Core and Core.TheApocalypse then
        Core.TheApocalypse.AutoLootItemName = nearestItem
    end
    return nearestLoot, nearestItem, nearestModel
end

local function getValidResourceTypes()
    if Config.AutoMine.Mode == "All" then
        return VALID_RESOURCE_TYPES
    else
        return { [Config.AutoMine.Mode] = true }
    end
end

local function getGridKey(pos)
    local cellSize = Config.AutoMine.GridCellSize
    local x = math.floor(pos.X / cellSize)
    local y = math.floor(pos.Y / cellSize)
    local z = math.floor(pos.Z / cellSize)
    return x .. "," .. y .. "," .. z
end

local function addResourceToGrid(obj, pos)
    if not obj:IsA("Model") or not obj.Parent or not obj.PrimaryPart then return end
    local config = obj:FindFirstChild("Configuration")
    local health = config and config:GetAttribute("Health") or 0
    if health <= 0 then return end
    
    local validTypes = getValidResourceTypes()
    for resourceType in pairs(validTypes) do
        if string.find(obj.Name, resourceType) then
            local resourceData = { obj = obj, position = pos, health = health }
            local key = getGridKey(pos)
            Cache.ResourceGrid[key] = Cache.ResourceGrid[key] or { Trees = {}, Stones = {}, Ores = {} }
            if PRIORITY_GROUPS.Trees[resourceType] then
                table.insert(Cache.ResourceGrid[key].Trees, resourceData)
            end
            if PRIORITY_GROUPS.Stones[resourceType] then
                table.insert(Cache.ResourceGrid[key].Stones, resourceData)
            end
            if PRIORITY_GROUPS.Ores[resourceType] then
                table.insert(Cache.ResourceGrid[key].Ores, resourceData)
            end
            break
        end
    end
end

local function removeResourceFromGrid(obj)
    for key, gridCell in pairs(Cache.ResourceGrid) do
        for _, group in pairs({"Trees", "Stones", "Ores"}) do
            for i = #gridCell[group], 1, -1 do
                if gridCell[group][i].obj == obj then
                    table.remove(gridCell[group], i)
                end
            end
        end
    end
end

local function initializeResourceCache()
    Cache.ResourceGrid = {}
    Cache.PendingResources = {}
    local validTypes = getValidResourceTypes()
    for _, obj in ipairs(Spawned:GetChildren()) do
        if obj:IsA("Model") and obj.Parent and obj.PrimaryPart then
            for resourceType in pairs(validTypes) do
                if string.find(obj.Name, resourceType) then
                    addResourceToGrid(obj, obj.PrimaryPart.Position)
                    break
                end
            end
        end
    end
    Cache.CacheValid.Resources = true
end

local function processPendingResources()
    local currentTime = tick()
    if currentTime - Cache.LastCacheUpdate < Config.AutoMine.CacheUpdateInterval then
        return
    end
    Cache.LastCacheUpdate = currentTime
    
    for _, obj in ipairs(Cache.PendingResources) do
        if obj.Parent and obj.PrimaryPart then
            addResourceToGrid(obj, obj.PrimaryPart.Position)
        end
    end
    Cache.PendingResources = {}
end

local function checkZombieAlert()
    if not Config.AutoMine.ZombieAlert_Enabled then
        return false
    end
    
    Cache.RootPart = Cache.RootPart or (Cache.Character and Cache.Character:FindFirstChild("HumanoidRootPart"))
    if not Cache.RootPart then return false end
    Cache.PlayerPosition = Cache.PlayerPosition or Cache.RootPart.Position
    
    local radiusSqr = Config.AutoMine.ZombieAlert_Radius ^ 2
    for _, enemy in ipairs(Enemies:GetChildren()) do
        local humanoid = enemy:FindFirstChildOfClass("Humanoid")
        local root = enemy:FindFirstChild("HumanoidRootPart")
        if humanoid and root and humanoid.Health > 0 then
            local dx = Cache.PlayerPosition.X - root.Position.X
            local dy = Cache.PlayerPosition.Y - root.Position.Y
            local dz = Cache.PlayerPosition.Z - root.Position.Z
            if dx * dx + dy * dy + dz * dz <= radiusSqr then
                return true
            end
        end
    end
    return false
end

local function findNearestResource()
    Cache.Character = Cache.Character or LocalPlayer.Character
    if not Cache.Character then
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.AutoMineOreName = nil
            Core.TheApocalypse.AutoMineHealthOre = nil
        end
        return nil
    end
    
    Cache.RootPart = Cache.RootPart or Cache.Character:FindFirstChild("HumanoidRootPart")
    if not Cache.RootPart then
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.AutoMineOreName = nil
            Core.TheApocalypse.AutoMineHealthOre = nil
        end
        return nil
    end
    
    local currentTime = tick()
    local playerPos = Cache.RootPart.Position
    if Cache.PlayerPosition and (currentTime - Cache.LastPositionUpdate < Config.AutoMine.CheckInterval) then
        local dx = playerPos.X - Cache.PlayerPosition.X
        local dy = playerPos.Y - Cache.PlayerPosition.Y
        local dz = playerPos.Z - Cache.PlayerPosition.Z
        if dx * dx + dy * dy + dz * dz < Config.AutoMine.PositionUpdateThreshold ^ 2 then
            playerPos = Cache.PlayerPosition
        else
            Cache.PlayerPosition = playerPos
            Cache.LastPositionUpdate = currentTime
        end
    else
        Cache.PlayerPosition = playerPos
        Cache.LastPositionUpdate = currentTime
    end
    
    if Cache.CurrentResource then
        local obj = Cache.CurrentResource.obj
        if obj and obj.Parent and obj.PrimaryPart then
            local config = obj:FindFirstChild("Configuration")
            local health = config and config:GetAttribute("Health") or 0
            if health > 0 then
                local dx = playerPos.X - Cache.CurrentResource.position.X
                local dy = playerPos.Y - Cache.CurrentResource.position.Y
                local dz = playerPos.Z - Cache.CurrentResource.position.Z
                if dx * dx + dy * dy + dz * dz <= Config.AutoMine.DistanceLimit ^ 2 then
                    Cache.CurrentResource.health = health
                    if Core and Core.TheApocalypse then
                        Core.TheApocalypse.AutoMineOreName = obj.Name
                        Core.TheApocalypse.AutoMineHealthOre = health
                    end
                    return obj
                end
            else
                removeHighlight(obj, "AutoMine")
                Cache.CurrentResource = nil
                if Core and Core.TheApocalypse then
                    Core.TheApocalypse.AutoMineOreName = nil
                    Core.TheApocalypse.AutoMineHealthOre = nil
                end
            end
        else
            removeHighlight(obj, "AutoMine")
            Cache.CurrentResource = nil
            if Core and Core.TheApocalypse then
                Core.TheApocalypse.AutoMineOreName = nil
                Core.TheApocalypse.AutoMineHealthOre = nil
            end
        end
    end
    
    if not Cache.CacheValid.Resources then
        initializeResourceCache()
    end
    processPendingResources()
    
    local distanceLimitSqr = Config.AutoMine.DistanceLimit ^ 2
    local earlyExitSqr = distanceLimitSqr * 0.3
    
    local function findClosestInGroup(group, gridCells)
        local closestResource, closestHealth, minDistanceSqr = nil, nil, distanceLimitSqr
        for _, key in ipairs(gridCells) do
            local cell = Cache.ResourceGrid[key]
            if cell then
                for _, resource in ipairs(cell[group]) do
                    if resource and resource.obj.Parent and resource.obj.PrimaryPart then
                        local config = resource.obj:FindFirstChild("Configuration")
                        local health = config and config:GetAttribute("Health") or 0
                        if health > 0 then
                            local dx = playerPos.X - resource.position.X
                            local dy = playerPos.Y - resource.position.Y
                            local dz = playerPos.Z - resource.position.Z
                            local distSqr = dx * dx + dy * dy + dz * dz
                            if distSqr <= minDistanceSqr then
                                closestResource = resource.obj
                                closestHealth = health
                                resource.health = health
                                minDistanceSqr = distSqr
                                if minDistanceSqr <= earlyExitSqr then break end
                            end
                        end
                    end
                end
                if minDistanceSqr <= earlyExitSqr then break end
            end
        end
        return closestResource, closestHealth, minDistanceSqr
    end
    
    local cellSize = Config.AutoMine.GridCellSize
    local gridRadius = math.ceil(Config.AutoMine.DistanceLimit / cellSize) + 1
    local playerX, playerY, playerZ = math.floor(playerPos.X / cellSize), math.floor(playerPos.Y / cellSize), math.floor(playerPos.Z / cellSize)
    local gridCells = {}
    for x = playerX - gridRadius, playerX + gridRadius do
        for y = playerY - gridRadius, playerY + gridRadius do
            for z = playerZ - gridRadius, playerZ + gridRadius do
                table.insert(gridCells, x .. "," .. y .. "," .. z)
            end
        end
    end
    
    local closestResource, closestHealth, closestDistanceSqr = nil, nil, math.huge
    local priorityGroup = Config.AutoMine.PrioritizeResources
    if priorityGroup ~= "None" then
        closestResource, closestHealth, closestDistanceSqr = findClosestInGroup(priorityGroup, gridCells)
        if closestResource then
            Cache.CurrentResource = { obj = closestResource, position = closestResource.PrimaryPart.Position, health = closestHealth }
            Cache.LastResourceCheck = currentTime
            if Core and Core.TheApocalypse then
                Core.TheApocalypse.AutoMineOreName = closestResource.Name
                Core.TheApocalypse.AutoMineHealthOre = closestHealth
            end
            return closestResource
        end
        for _, group in ipairs({ "Trees", "Stones", "Ores" }) do
            if group ~= priorityGroup then
                local groupResource, groupHealth, groupDistanceSqr = findClosestInGroup(group, gridCells)
                if groupResource and groupDistanceSqr < closestDistanceSqr then
                    closestResource = groupResource
                    closestHealth = groupHealth
                    closestDistanceSqr = groupDistanceSqr
                end
            end
        end
    else
        for _, group in ipairs({ "Trees", "Stones", "Ores"}) do
            local groupResource, groupHealth, groupDistanceSqr = findClosestInGroup(group, gridCells)
            if groupResource and groupDistanceSqr < closestDistanceSqr then
                closestResource = groupResource
                closestHealth = groupHealth
                closestDistanceSqr = groupDistanceSqr
            end
        end
    end
    
    Cache.CurrentResource = closestResource and { obj = closestResource, position = closestResource.PrimaryPart.Position, health = closestHealth }
    Cache.LastResourceCheck = currentTime
    if Core and Core.TheApocalypse then
        Core.TheApocalypse.AutoMineOreName = closestResource and closestResource.Name or nil
        Core.TheApocalypse.AutoMineHealthOre = closestResource and closestHealth or nil
    end
    return closestResource
end

local function getNearestTarget()
    Cache.Character = Cache.Character or LocalPlayer.Character
    if not Cache.Character then
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.isTargetNear = false
        end
        return nil
    end
    
    Cache.RootPart = Cache.RootPart or Cache.Character:FindFirstChild("HumanoidRootPart")
    if not Cache.RootPart then
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.isTargetNear = false
        end
        return nil
    end
    
    local currentTime = tick()
    local playerPos = Cache.RootPart.Position
    if Cache.PlayerPosition and (currentTime - Cache.LastPositionUpdate < Config.AutoMine.CheckInterval) then
        local dx = playerPos.X - Cache.PlayerPosition.X
        local dy = playerPos.Y - Cache.PlayerPosition.Y
        local dz = playerPos.Z - Cache.PlayerPosition.Z
        if dx * dx + dy * dy + dz * dz < Config.AutoMine.PositionUpdateThreshold ^ 2 then
            playerPos = Cache.PlayerPosition
        else
            Cache.PlayerPosition = playerPos
            Cache.LastPositionUpdate = currentTime
        end
    else
        Cache.PlayerPosition = playerPos
        Cache.LastPositionUpdate = currentTime
    end
    
    if Cache.CurrentTarget and currentTime - Cache.LastTargetCheck < Cache.TargetCheckInterval then
        local humanoid = Cache.CurrentTarget:FindFirstChildOfClass("Humanoid")
        local root = Cache.CurrentTarget:FindFirstChild("HumanoidRootPart")
        local serverModel = Cache.CurrentTarget:FindFirstChild("ServerModel")
        if humanoid and root and humanoid.Health > 0 and serverModel and serverModel.Value then
            local dx = playerPos.X - root.Position.X
            local dy = playerPos.Y - root.Position.Y
            local dz = playerPos.Z - root.Position.Z
            if dx * dx + dy * dy + dz * dz <= Config.KillAura.MaxDistance ^ 2 then
                if Core and Core.TheApocalypse then
                    Core.TheApocalypse.isTargetNear = true
                end
                return Cache.CurrentTarget
            else
                removeHighlight(Cache.CurrentTarget, "KillAura")
                Cache.CurrentTarget = nil
            end
        else
            removeHighlight(Cache.CurrentTarget, "KillAura")
            Cache.CurrentTarget = nil
        end
    end
    
    local nearestTarget, minDistanceSqr = nil, Config.KillAura.MaxDistance ^ 2
    for _, enemy in ipairs(Enemies:GetChildren()) do
        local humanoid = enemy:FindFirstChildOfClass("Humanoid")
        local root = enemy:FindFirstChild("HumanoidRootPart")
        local serverModel = enemy:FindFirstChild("ServerModel")
        
        if humanoid and root and humanoid.Health > 0 and serverModel and serverModel.Value then
            local dx = playerPos.X - root.Position.X
            local dy = playerPos.Y - root.Position.Y
            local dz = playerPos.Z - root.Position.Z
            local distSqr = dx * dx + dy * dy + dz * dz
            if distSqr <= minDistanceSqr then
                nearestTarget = enemy
                minDistanceSqr = distSqr
            end
        end
    end
    
    if Cache.CurrentTarget and Cache.CurrentTarget ~= nearestTarget then
        removeHighlight(Cache.CurrentTarget, "KillAura")
    end
    Cache.CurrentTarget = nearestTarget
    Cache.LastTargetCheck = currentTime
    if Core and Core.TheApocalypse then
        Core.TheApocalypse.isTargetNear = nearestTarget ~= nil
    end
    return nearestTarget
end

local function attackTarget(target, useRate)
    if not target then return end
    
    Cache.RootPart = Cache.RootPart or (Cache.Character and Cache.Character:FindFirstChild("HumanoidRootPart"))
    if not Cache.RootPart then return end
    
    local root = target:FindFirstChild("HumanoidRootPart")
    if not root then return end
    
    local dx = Cache.RootPart.Position.X - root.Position.X
    local dy = Cache.RootPart.Position.Y - root.Position.Y
    local dz = Cache.RootPart.Position.Z - root.Position.Z
    if dx * dx + dy * dy + dz * dz > Config.KillAura.MaxDistance ^ 2 then
        removeHighlight(target, "KillAura")
        return
    end
    
    createHighlight(target, "KillAura")
    local serverTarget = target.ServerModel.Value
    if not serverTarget then return end
    
    ToolAction:FireServer("click", serverTarget)
    
    local finalDelay = math.max(0, useRate + 0.1 - Config.KillAura.MinusUseRate)
    task.wait(finalDelay)
    
    if Config.KillAura.AutoRemoveHighlightDelay > 0 then
        task.wait(Config.KillAura.AutoRemoveHighlightDelay)
    end
    
    if Cache.CurrentTarget ~= target then
        removeHighlight(target, "KillAura")
    end
end

local function hitResource(target, item, useRate)
    if not target or not item then
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.AutoMineOreName = nil
            Core.TheApocalypse.AutoMineHealthOre = nil
        end
        return
    end
    
    local config = target:FindFirstChild("Configuration")
    local health = config and config:GetAttribute("Health") or 0
    if health <= 0 then
        if Cache.CurrentResource and Cache.CurrentResource.obj == target then
            Cache.CurrentResource = nil
        end
        removeHighlight(target, "AutoMine")
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.AutoMineOreName = nil
            Core.TheApocalypse.AutoMineHealthOre = nil
        end
        return
    end
    
    createHighlight(target, "AutoMine")
    if Core and Core.TheApocalypse then
        Core.TheApocalypse.AutoMineOreName = target.Name
        Core.TheApocalypse.AutoMineHealthOre = health
    end
    ToolAction:FireServer("click", target, false)
    
    task.wait(useRate)
    
    if Cache.CurrentResource and Cache.CurrentResource.obj ~= target then
        removeHighlight(target, "AutoMine")
    end
end

local function mainLoop()
    LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        Cache.Character = newCharacter
        Cache.RootPart = nil
        Cache.PlayerPosition = nil
        Cache.CacheValid.Resources = false
        Cache.CacheValid.Loot = false
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.isTargetNear = false
            Core.TheApocalypse.AutoMineOreName = nil
            Core.TheApocalypse.AutoMineHealthOre = nil
            Core.TheApocalypse.AutoLootItemName = nil
        end
    end)
    
    local prevResource = nil
    while true do
        Cache.Character = Cache.Character or LocalPlayer.Character
        if not Cache.Character then
            Cache.RootPart = nil
            Cache.PlayerPosition = nil
            if Core and Core.TheApocalypse then
                Core.TheApocalypse.isTargetNear = false
                Core.TheApocalypse.AutoMineOreName = nil
                Core.TheApocalypse.AutoMineHealthOre = nil
                Core.TheApocalypse.AutoLootItemName = nil
            end
            clearKillAuraHighlights(nil)
            clearAutoLootHighlights(nil)
            task.wait(0.03)
            continue
        end
        
        if Config.KillAura.Enabled then
            local isValid, useRate = isValidWeapon()
            if isValid then
                local target = getNearestTarget()
                clearKillAuraHighlights(target)
                if target then
                    attackTarget(target, useRate)
                else
                    task.wait(0.03)
                end
            else
                clearKillAuraHighlights(nil)
                task.wait(0.03)
            end
        else
            clearKillAuraHighlights(nil)
        end
        
        if Config.AutoMine.Enabled then
            local item, useRate = findPlayerItem()
            if item then
                if Config.AutoMine.ZombieAlert_Enabled and checkZombieAlert() then
                    if prevResource then
                        removeHighlight(prevResource, "AutoMine")
                        prevResource = nil
                    end
                    if Core and Core.TheApocalypse then
                        Core.TheApocalypse.AutoMineOreName = nil
                        Core.TheApocalypse.AutoMineHealthOre = nil
                    end
                    task.wait(Config.AutoMine.CheckInterval)
                else
                    local resource = findNearestResource()
                    if resource then
                        if prevResource and prevResource != resource then
                            removeHighlight(prevResource, "AutoMine")
                        end
                        hitResource(resource, item, useRate)
                        prevResource = resource
                    else
                        if prevResource then
                            removeHighlight(prevResource, "AutoMine")
                            prevResource = nil
                        end
                        if Core and Core.TheApocalypse then
                            Core.TheApocalypse.AutoMineOreName = nil
                            Core.TheApocalypse.AutoMineHealthOre = nil
                        end
                        task.wait(Config.AutoMine.CheckInterval)
                    end
                end
            else
                if prevResource then
                    removeHighlight(prevResource, "AutoMine")
                    prevResource = nil
                end
                if Core and Core.TheApocalypse then
                    Core.TheApocalypse.AutoMineOreName = nil
                    Core.TheApocalypse.AutoMineHealthOre = nil
                end
                task.wait(Config.AutoMine.CheckInterval)
            end
        else
            if prevResource then
                removeHighlight(prevResource, "AutoMine")
                prevResource = nil
            end
            if Core and Core.TheApocalypse then
                Core.TheApocalypse.AutoMineOreName = nil
                Core.TheApocalypse.AutoMineHealthOre = nil
            end
        end
        
        if Config.AutoLoot.Enabled then
            local data = LocalPlayer:WaitForChild("Data")
            local inventory = LocalPlayer:WaitForChild("Inventory")
            local inventorySize = data:WaitForChild("InventorySize")
            if not inventory or not inventorySize then
                task.wait(0.03)
                continue
            end
            
            local maxSlots = inventorySize.Value
            if maxSlots <= 0 then
                task.wait(0.03)
                continue
            end
            
            local currentTime = tick()
            if currentTime - Cache.LastLootCheck < Config.AutoLoot.CheckInterval then
                task.wait(0.03)
                continue
            end
            Cache.LastLootCheck = currentTime
            
            local lootItem, itemName, lootModel = findNearestLoot()
            if not lootItem or not itemName then
                task.wait(0.03)
                continue
            end
            
            local countValue = lootItem:FindFirstChild("Count")
            local lootCount = countValue and countValue.Value or 1
            local baseItemName = getBaseItemName(itemName)
            local itemConfig = getItemConfig(baseItemName)
            local playerItemFolder, existingSlot = findExistingItemFolder(inventory, itemName, lootItem)
            
            if playerItemFolder then
                local playerCountValue = playerItemFolder:FindFirstChild("Count")
                local playerCount = playerCountValue and playerCountValue.Value or 0
                if playerCount < itemConfig.maxStack then
                    local args = {
                        [1] = lootItem,
                        [2] = playerItemFolder
                    }
                    local mergeAmount = math.min(lootCount, itemConfig.maxStack - playerCount)
                    notify("AutoLoot", "Merging " .. mergeAmount .. "x " .. itemName .. " to slot " .. existingSlot, false)
                    MergeItems:FireServer(unpack(args))
                    task.wait(Config.AutoLoot.ActionDelay)
                end
            else
                local freeSlot = findFreeSlot(inventory, maxSlots)
                if freeSlot and (Config.AutoLoot.UseFreeSlotWhileWaiting or not findExistingItemFolder(inventory, itemName, lootItem)) then
                    local args = {
                        [1] = lootItem,
                        [2] = "Inventory",
                        [3] = freeSlot
                    }
                    notify("AutoLoot", "Moving " .. itemName .. " to slot " .. freeSlot, false)
                    MoveItem:FireServer(unpack(args))
                    task.wait(Config.AutoLoot.ActionDelay)
                else
                    if itemConfig.maxStack > 1 then
                        for _, itemFolder in ipairs(inventory:GetChildren()) do
                            if getBaseItemName(itemFolder.Name) == baseItemName then
                                local countValue = itemFolder:FindFirstChild("Count")
                                local indexValue = itemFolder:FindFirstChild("Index")
                                if countValue and indexValue and countValue.Value < itemConfig.maxStack and itemFolder ~= lootItem and itemFolder.Parent then
                                    local playerCount = countValue.Value
                                    local mergeAmount = math.min(lootCount, itemConfig.maxStack - playerCount)
                                    local args = {
                                        [1] = lootItem,
                                        [2] = itemFolder
                                    }
                                    notify("AutoLoot", "Merging " .. mergeAmount .. "x " .. itemName .. " to slot " .. indexValue.Value, false)
                                    MergeItems:FireServer(unpack(args))
                                    task.wait(Config.AutoLoot.ActionDelay)
                                    break
                                end
                            end
                        end
                    end
                end
            end
        else
            clearAutoLootHighlights(nil)
            if Core and Core.TheApocalypse then
                Core.TheApocalypse.AutoLootItemName = nil
            end
        end
        
        if not Config.KillAura.Enabled and not Config.AutoMine.Enabled and not Config.AutoLoot.Enabled then
            task.wait(0.03)
        end
    end
end

local function initializeItemCache()
    for _, itemModel in ipairs(Items:GetChildren()) do
        getItemConfig(itemModel.Name)
    end
end

Spawned.ChildAdded:Connect(function(child)
    if child:IsA("Model") and child.Parent and child.PrimaryPart then
        local lootTypes = getLootTypes()
        if lootTypes[child.Name] then
            local inventoryFolder = child:FindFirstChild("Inventory")
            if inventoryFolder then
                local items = {}
                for _, itemFolder in ipairs(inventoryFolder:GetChildren()) do
                    if isItemAllowed(itemFolder.Name) then
                        table.insert(items, itemFolder)
                    end
                end
                if #items > 0 then
                    addLootToGrid(child, child.PrimaryPart.Position, items)
                    if Config.AutoLoot.Enabled then
                        createHighlight(child, "AutoLoot")
                    end
                end
            end
        end
        table.insert(Cache.PendingResources, child)
    end
end)

Spawned.ChildRemoved:Connect(function(child)
    if Cache.CurrentResource and Cache.CurrentResource.obj == child then
        Cache.CurrentResource = nil
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.AutoMineOreName = nil
            Core.TheApocalypse.AutoMineHealthOre = nil
        end
    end
    if Cache.LootCache[child] then
        if Cache.CurrentLoot == child then
            removeHighlight(Cache.CurrentLoot, "AutoLoot")
            Cache.CurrentLoot = nil
            if Core and Core.TheApocalypse then
                Core.TheApocalypse.AutoLootItemName = nil
            end
        end
        removeLootFromGrid(child)
    end
    removeResourceFromGrid(child)
    removeHighlight(child, "AutoMine")
    removeHighlight(child, "AutoLoot")
end)

Enemies.ChildRemoved:Connect(function(child)
    if Cache.CurrentTarget and Cache.CurrentTarget == child then
        Cache.CurrentTarget = nil
        if Core and Core.TheApocalypse then
            Core.TheApocalypse.isTargetNear = false
        end
    end
    removeHighlight(child, "KillAura")
end)

local function initializeUI(UI)
    if UI.Tabs and UI.Tabs.Main then
        local killAuraSection = UI.Tabs.Main:Section({ Name = "KillAura", Side = "Right" })
        killAuraSection:Header({ Name = "KillAura" })
        killAuraSection:SubLabel({ Text = "Automates melee attacks on nearby enemies" })
        
        uiElements.KillAuraEnabled = killAuraSection:Toggle({
            Name = "Enabled",
            Default = Config.KillAura.Enabled,
            Callback = function(value)
                Config.KillAura.Enabled = value
                if not value then clearKillAuraHighlights(nil) end
                notify("KillAura", "KillAura " .. (value and "Enabled" or "Disabled"), true)
            end
        }, 'KillAuraEnabled')
        
        uiElements.KillAuraMaxDistance = killAuraSection:Slider({
            Name = "Max Distance",
            Minimum = 5,
            Maximum = 30,
            Default = Config.KillAura.MaxDistance,
            Precision = 1,
            Callback = function(value)
                Config.KillAura.MaxDistance = value
                clearKillAuraHighlights(Cache.CurrentTarget)
                notify("KillAura", "Max Distance set to: " .. value, false)
            end
        }, 'KillAuraMaxDistance')
        
        uiElements.KillAuraHighlightEnabled = killAuraSection:Toggle({
            Name = "Highlight Enabled",
            Default = Config.KillAura.HighlightEnabled,
            Callback = function(value)
                Config.KillAura.HighlightEnabled = value
                if not value then clearKillAuraHighlights(nil) end
                notify("KillAura", "Highlight " .. (value and "Enabled" or "Disabled"), true)
            end
        }, 'KillAuraHighlightEnabled')
        
        uiElements.KillAuraHighlightColor = killAuraSection:Colorpicker({
            Name = "Highlight Color",
            Default = Config.KillAura.HighlightColor,
            Callback = function(value)
                Config.KillAura.HighlightColor = value
                notify("KillAura", "Highlight Color updated", false)
            end
        }, 'KillAuraHighlightColor')
        killAuraSection:Divider()
        uiElements.KillAuraMinusUseRate = killAuraSection:Slider({
            Name = "Minus UseRate",
            Minimum = 0,
            Maximum = 0.5,
            Default = Config.KillAura.MinusUseRate,
            Precision = 2,
            Callback = function(value)
                Config.KillAura.MinusUseRate = value
                notify("KillAura", "Minus Use Rate set to: " .. value, false)
            end
        }, 'KillAuraMinusUseRate')
        killAuraSection:SubLabel({ Text = "[ ⁉️ ] Reduces the delay before the next KillAura attack" })
        killAuraSection:Divider()
        
        local autoMineSection = UI.Tabs.Main:Section({ Name = "AutoMine", Side = "Left" })
        autoMineSection:Header({ Name = "AutoMine" })
        autoMineSection:SubLabel({ Text = "Automates resource farm" })
        
        uiElements.AutoMineEnabled = autoMineSection:Toggle({
            Name = "Enabled",
            Default = Config.AutoMine.Enabled,
            Callback = function(value)
                Config.AutoMine.Enabled = value
                notify("AutoMine", "AutoMine " .. (value and "Enabled" or "Disabled"), true)
            end
        }, 'AutoMineEnabled')
        
        uiElements.AutoMineDistanceLimit = autoMineSection:Slider({
            Name = "Max Distance",
            Minimum = 20,
            Maximum = 1500,
            Default = Config.AutoMine.DistanceLimit,
            Precision = 0,
            Callback = function(value)
                Config.AutoMine.DistanceLimit = value
                Cache.CacheValid.Resources = false
                notify("AutoMine", "Max Distance set to: " .. value, false)
            end
        }, 'AutoMineDistanceLimit')
        autoMineSection:Divider()
        uiElements.AutoMineCheckInterval = autoMineSection:Slider({
            Name = "Check Interval",
            Minimum = 0.1,
            Maximum = 0.5,
            Default = Config.AutoMine.CheckInterval,
            Precision = 2,
            Callback = function(value)
                Config.AutoMine.CheckInterval = value
                notify("AutoMine", "Check Interval set to: " .. value, false)
            end
        }, 'AutoMineCheckInterval')
        autoMineSection:Divider()
        uiElements.AutoMineHighlightEnabled = autoMineSection:Toggle({
            Name = "Highlight Enabled",
            Default = Config.AutoMine.HighlightEnabled,
            Callback = function(value)
                Config.AutoMine.HighlightEnabled = value
                notify("AutoMine", "Highlight " .. (value and "Enabled" or "Disabled"), true)
            end
        }, 'AutoMineHighlightEnabled')
        
        uiElements.AutoMineHighlightColor = autoMineSection:Colorpicker({
            Name = "Highlight Color",
            Default = Config.AutoMine.HighlightColor,
            Callback = function(value)
                Config.AutoMine.HighlightColor = value
                notify("AutoMine", "Highlight Color updated", false)
            end
        }, 'AutoMineHighlightColor')
        
        uiElements.AutoMineMode = autoMineSection:Dropdown({
            Name = "Mode",
            Default = Config.AutoMine.Mode,
            Options = { "All", "Tree", "Stone", "Coal", "IronOre", "CopperOre", "Palm", "Sandstone" },
            Search = true,
            Callback = function(value)
                Config.AutoMine.Mode = value
                Cache.CacheValid.Resources = false
                notify("AutoMine", "Mode set to: " .. value, false)
            end
        }, 'AutoMineMode')
        
        uiElements.AutoMinePrioritizeResources = autoMineSection:Dropdown({
            Name = "Prioritize Resources",
            Default = Config.AutoMine.PrioritizeResources,
            Options = { "None", "Trees", "Stones", "Ores" },
            Search = true,
            Callback = function(value)
                Config.AutoMine.PrioritizeResources = value
                notify("AutoMine", "Prioritize Resources set to: " .. value, false)
            end
        }, 'AutoMinePrioritizeResources')
        autoMineSection:Divider()
        uiElements.AutoMineZombieAlertEnabled = autoMineSection:Toggle({
            Name = "Zombie Alert",
            Default = Config.AutoMine.ZombieAlert_Enabled,
            Callback = function(value)
                Config.AutoMine.ZombieAlert_Enabled = value
                notify("AutoMine", "Zombie Alert " .. (value and "Enabled" or "Disabled"), true)
            end
        }, 'AutoMineZombieAlertEnabled')
        autoMineSection:SubLabel({ Text = "[ ⁉️ ] Stops farming resources when an enemy is nearby" })
        uiElements.AutoMineZombieAlertRadius = autoMineSection:Slider({
            Name = "Alert Radius",
            Minimum = 20,
            Maximum = 100,
            Default = Config.AutoMine.ZombieAlert_Radius,
            Precision = 0,
            Callback = function(value)
                Config.AutoMine.ZombieAlert_Radius = value
                notify("AutoMine", "Zombie Alert Radius set to: " .. value, false)
            end
        }, 'AutoMineZombieAlertRadius')
        autoMineSection:Divider()
        uiElements.AutoMineGridCellSize = autoMineSection:Slider({
            Name = "GridCellSize",
            Minimum = 25,
            Maximum = 250,
            Default = Config.AutoMine.GridCellSize,
            Precision = 0,
            Callback = function(value)
                Config.AutoMine.GridCellSize = value
                Cache.CacheValid.Resources = false
                notify("AutoMine", "Grid Cell Size set to: " .. value, false)
            end
        }, 'AutoMineGridCellSize')
        autoMineSection:SubLabel({ Text = "[❗] Not recommend to change" })
        
        local autoLootSection = UI.Tabs.Main:Section({ Name = "AutoLoot", Side = "Right" })
        autoLootSection:Header({ Name = "AutoLoot" })
        autoLootSection:SubLabel({ Text = "Automates loot collection from crates" })
        
        uiElements.AutoLootEnabled = autoLootSection:Toggle({
            Name = "Enabled",
            Default = Config.AutoLoot.Enabled,
            Callback = function(value)
                Config.AutoLoot.Enabled = value
                if not value then
                    clearAutoLootHighlights(nil)
                    if Core and Core.TheApocalypse then
                        Core.TheApocalypse.AutoLootItemName = nil
                    end
                end
                notify("AutoLoot", "AutoLoot " .. (value and "Enabled" or "Disabled"), true)
            end
        })
        
        uiElements.AutoLootMaxDistance = autoLootSection:Slider({
            Name = "Max Distance",
            Minimum = 20,
            Maximum = 1500,
            Default = Config.AutoLoot.MaxDistance,
            Precision = 0,
            Callback = function(value)
                Config.AutoLoot.MaxDistance = value
                Cache.CacheValid.Loot = false
                notify("AutoLoot", "Max Distance set to: " .. value, false)
            end
        })
        autoLootSection:Divider()
        
        uiElements.AutoLootCheckInterval = autoLootSection:Slider({
            Name = "Check Interval",
            Minimum = 0.1,
            Maximum = 1.0,
            Default = Config.AutoLoot.CheckInterval,
            Precision = 2,
            Callback = function(value)
                Config.AutoLoot.CheckInterval = value
                notify("AutoLoot", "Check Interval set to: " .. value, false)
            end
        })
        autoLootSection:Divider()
        
        uiElements.AutoLootValidationDelay = autoLootSection:Slider({
            Name = "Validation Delay",
            Minimum = 0.1,
            Maximum = 2,
            Default = Config.AutoLoot.ValidationDelay,
            Precision = 1,
            Callback = function(value)
                Config.AutoLoot.ValidationDelay = value
                notify("AutoLoot", "Validation Delay set to: " .. value, false)
            end
        })
        autoLootSection:SubLabel({ Text = "[ ⁉️ ] Delay for validating items in inventory" })
        autoLootSection:Divider()
        
        uiElements.AutoLootHighlightEnabled = autoLootSection:Toggle({
            Name = "Highlight Enabled",
            Default = Config.AutoLoot.HighlightEnabled,
            Callback = function(value)
                Config.AutoLoot.HighlightEnabled = value
                if not value then
                    clearAutoLootHighlights(nil)
                    if Core and Core.TheApocalypse then
                        Core.TheApocalypse.AutoLootItemName = nil
                    end
                end
                notify("AutoLoot", "Highlight " .. (value and "Enabled" or "Disabled"), true)
            end
        })
        
        uiElements.AutoLootHighlightColor = autoLootSection:Colorpicker({
            Name = "Highlight Color",
            Default = Config.AutoLoot.HighlightColor,
            Callback = function(value)
                Config.AutoLoot.HighlightColor = value
                notify("AutoLoot", "Highlight Color updated", false)
            end
        })
        autoLootSection:Divider()
        
        uiElements.AutoLootMode = autoLootSection:Dropdown({
            Name = "Mode",
            Default = Config.AutoLoot.Mode,
            Options = { "None", "Exact", "Exclude" },
            Search = true,
            Callback = function(value)
                Config.AutoLoot.Mode = value
                Cache.CacheValid.Loot = false
                notify("AutoLoot", "Mode set to: " .. value, false)
            end
        })
        autoLootSection:SubLabel({ Text = "[ ⁉️ ] None: All items, Exact: Only selected, Exclude: All except selected" })
        
        uiElements.AutoLootLootCrates = autoLootSection:Dropdown({
            Name = "Loot Crates",
            Default = Config.AutoLoot.LootCrates,
            Options = { "All", "Common", "Rare", "Uncommon" },
            Search = true,
            Multi = true,
            Callback = function(value)
                Config.AutoLoot.LootCrates = value
                Cache.CacheValid.Loot = false
                notify("AutoLoot", "Loot Crates updated", false)
            end
        })
        
        local itemOptions = {}
        for _, item in ipairs(Items:GetChildren()) do
            local itemConfig = getItemConfig(item.Name)
            if itemConfig.class == "consumable" or itemConfig.class == "resource" then
                table.insert(itemOptions, item.Name)
            end
        end
        table.sort(itemOptions)
        uiElements.AutoLootItemsList = autoLootSection:Dropdown({
            Name = "Items List",
            Default = Config.AutoLoot.ItemsList,
            Options = itemOptions,
            Search = true,
            Multi = true,
            Callback = function(value)
                Config.AutoLoot.ItemsList = value
                Cache.CacheValid.Loot = false
                notify("AutoLoot", "Items List updated", false)
            end
        })
        autoLootSection:SubLabel({ Text = "[ ⁉️ ] Select items for Exact or Exclude mode" })
        
        if UI.Tabs.Config then
            local configSection = UI.Tabs.Config:Section({ Name = "KillAura, AutoMine, AutoLoot Sync", Side = "Right" })
            configSection:Header({ Name = "KillAura, AutoMine, AutoLoot Settings Sync" })
            configSection:Button({
                Name = "Sync Config",
                Callback = function()
                    local killAuraMaxDistance = uiElements.KillAuraMaxDistance:GetValue()
                    local killAuraMinusUseRate = uiElements.KillAuraMinusUseRate:GetValue()
                    local autoMineDistanceLimit = uiElements.AutoMineDistanceLimit:GetValue()
                    local autoMineCheckInterval = uiElements.AutoMineCheckInterval:GetValue()
                    local autoMineZombieAlertRadius = uiElements.AutoMineZombieAlertRadius:GetValue()
                    local autoMineGridCellSize = uiElements.AutoMineGridCellSize:GetValue()
                    
                    Config.KillAura.MaxDistance = killAuraMaxDistance
                    Config.KillAura.MinusUseRate = killAuraMinusUseRate
                    Config.AutoMine.DistanceLimit = autoMineDistanceLimit
                    Config.AutoMine.CheckInterval = autoMineCheckInterval
                    Config.AutoMine.ZombieAlert_Radius = autoMineZombieAlertRadius
                    Config.AutoMine.GridCellSize = autoMineGridCellSize
                    notify("Config", "KillAura MaxDistance: " .. tostring(killAuraMaxDistance), false)
                    notify("Config", "KillAura MinusUseRate: " .. tostring(killAuraMinusUseRate), false)
                    notify("Config", "AutoMine DistanceLimit: " .. tostring(autoMineDistanceLimit), false)
                    notify("Config", "AutoMine CheckInterval: " .. tostring(autoMineCheckInterval), false)
                    notify("Config", "AutoMine ZombieAlertRadius: " .. tostring(autoMineZombieAlertRadius), false)
                    notify("Config", "AutoMine GridCellSize: " .. tostring(autoMineGridCellSize), false)
                    notify("Config", "KillAura, AutoMine, and AutoLoot sliders synchronized!", true)
                end
            })
        else
            notify("Error", "Main tab not found in UI.Tabs", false)
        end
    end
end

initializeResourceCache()
initializeItemCache()

task.spawn(mainLoop)

local function init(UI, core, notif)
    Core = core
    notify = notif or print
    if Core then
        Core.TheApocalypse = {
            isTargetNear = false,
            AutoMineOreName = nil,
            AutoMineHealthOre = nil,
            AutoLootItemName = nil
        }
    end
    if UI then
        initializeUI(UI)
    end
end

return { Init = init }